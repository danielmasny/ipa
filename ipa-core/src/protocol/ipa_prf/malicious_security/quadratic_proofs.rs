use futures_util::future;
use generic_array::{ArrayLength, GenericArray};
use hkdf::Hkdf;
use sha2::Sha256;
use typenum::Unsigned;

use crate::{
    ff::{Error, Field, Invert, Serializable},
    protocol::{
        context::Context, ipa_prf::malicious_security::lagrange::lagrange_evaluation,
        prss::SharedRandomness, RecordId,
    },
    secret_sharing::replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
};

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the vector length of `g_left` determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used Vec instead of GenArray)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    proofs: Vec<Vec<F>>,
}

/// generates recursive proof for sum_i u_i*v_i = out over field F
/// `recursion_factor` determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
/// this proof is sent to the party on the left
/// it is therefore the "right proof" of the party on the left
/// the left part of the proof is implicitly generated by the party on the right using left prss during verification
pub fn generate_proof<F>(
    //ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    recursion_factor: usize,
) -> NIDZKP<F>
where
    F: Field + Invert,
    //C: Context,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    let mut output = NIDZKP {
        proofs: Vec::with_capacity(1),
    };

    // record counter
    let mut counter = 0usize;

    // generate evaluation points `(F::0..F::(i)..)`
    let evaluation_points = (0..2 * recursion_factor + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // iterate over recursions
    while u.len() > recursion_factor {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        u.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));
        v.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = u.len() / recursion_factor;

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * recursion_factor];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(recursion_factor)
            .zip(v.chunks(recursion_factor))
            .for_each(|(u, v)| {
                compute_summand_of_g(
                    u,
                    v,
                    recursion_factor,
                    &evaluation_points[0..2 * recursion_factor],
                    &mut g,
                )
            });

        // compute secret share g_left (i.e. part of the proof recovered by right party) using prss_right
        let mut g_left = vec![F::ZERO; g.len()];
        g_left.iter_mut().for_each(|g| {
            // get prss
            // todo replace `F::ONE` with actual prss value

            // compute `g_left`
            *g = F::ONE;
        });

        // compute secret share `g_right` by computing `g_right=g-g_left`
        // since `g` already contains `g`, we just need to subtract `g_left`
        g.iter_mut()
            .zip(g_left.iter())
            .for_each(|(g_right, g_left)| *g_right -= *g_left);

        // compute random point `r` via `Fiat-Shamir` hash
        // generate `r` as `hash(g_right) + hash(g_right)`
        let mut r = F::ZERO;
        compute_r_prover(&g, &g_left, &mut r);

        // add `g_right` to proof
        output.proofs.push(g);

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; s];
        u_new
            .iter_mut()
            .zip(u.chunks(recursion_factor))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(u),
                )
            });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; s];
        v_new
            .iter_mut()
            .zip(v.chunks(recursion_factor))
            .for_each(|(v, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(v),
                )
            });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(s);
        v.truncate(s);
    }

    // define last g
    // since we add masks, the degree of g might be larger
    let mut final_g = vec![F::ZERO; 2 * u.len() + 2];

    // generate final `evaluation_points`
    // generate mask p[0] from prss_right and append to u
    // generate mask q[0] from prss_right and append to v
    // todo
    let (final_u, final_v) = {
        let mut vec_u = Vec::<F>::with_capacity(u.len() + 1);
        let mut vec_v = Vec::<F>::with_capacity(u.len() + 1);
        // add prss masks
        // todo
        vec_u.push(F::ONE);
        vec_v.push(F::ONE);
        // copy rest
        vec_u.extend(&*u);
        vec_v.extend(&*v);
        (vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(
        &final_u,
        &final_v,
        final_u.len(),
        &evaluation_points[..2 * u.len() + 2],
        &mut final_g,
    );

    // generate last secret share
    let mut g_left = vec![F::ZERO; final_g.len()];
    g_left.iter_mut().for_each(|g| {
        // get prss
        // todo replace `F::ONE` with actual prss value

        // compute `g_left`
        *g = F::ONE;
    });

    // add secret share of g to the proofs
    // todo
    final_g
        .iter_mut()
        .zip(g_left.iter())
        .for_each(|(g_right, g_left)| *g_right -= *g_left);

    output.proofs.push(final_g);

    return output;
}

/// verify proof
/// needs interaction to compute the hashes, i.e. random points
// need to change it to async once prss is incorporated
// todo
pub fn verify_proof<F>(
    //ctx: C,
    proof_right: &NIDZKP<F>,
    out: &F,
    share_of_u: (&mut Vec<F>, &mut Vec<F>),
    share_of_v: (&mut Vec<F>, &mut Vec<F>),
) -> Result<bool, Error>
where
    //C: Context,
    F: Field + Invert,
{
    // setup output
    let mut output = true;

    // check that there is at least one recursion
    debug_assert!(proof_right.proofs.len() > 1);
    // compute recursion factor
    let r_f = proof_right.proofs[0].len() >> 1;

    // generate evaluation points `(F::0..F::(i)..)`
    let e_p = (0..2 * r_f + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // compute left part of the proof
    // todo
    let proof_left = &mut NIDZKP {
        proofs: Vec::with_capacity(proof_right.proofs.len()),
    };
    proof_right
        .proofs
        .iter()
        // add prss value to proof
        // todo
        .for_each(|x| proof_left.proofs.push(vec![F::ONE; x.len()]));

    // declarations
    let mut r_right = vec![F::ZERO; proof_right.proofs.len()];
    let mut r_left = vec![F::ZERO; proof_left.proofs.len()];
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len() + 1];
    let mut g_r_left = vec![F::ONE; proof_left.proofs.len() + 1];

    // dummy fs:
    r_left
        .iter_mut()
        .zip(r_right.iter_mut())
        .zip(proof_left.proofs.iter().zip(proof_right.proofs.iter()))
        .for_each(|((r_left, r_right), (proof_left, proof_right))| {
            compute_r_prover(&proof_left, &proof_right, r_left);
            *r_right = *r_left;
        });

    for (r, g_r, proof, g_r_0) in [
        (&r_right, &mut g_r_right, proof_right, out),
        (&r_left, &mut g_r_left, proof_left, &F::ZERO),
    ] {
        // compute r's using fiat+shamir
        // todo replace dummy fs above with `compute_r_verifier`

        // last `r` is not allowed to be in `evaluation_points[0..recursion_factor]`
        // therefore, we use `compute_final_r`
        //
        // todo

        // then compute g_r using lagrange_evaluation
        compute_g_r(proof, g_r_0, r, r_f, &e_p, g_r);

        // compute `g_r = g_r-sum g(x)`
        compute_sums_gr_gm(proof, g_r);
    }

    // zero test
    // check that all sums `g_r == 0`
    // todo
    // dummy debug zero test:
    g_r_right[0..g_r_right.len() - 1]
        .iter()
        .zip(g_r_left[0..g_r_left.len() - 1].iter())
        .enumerate()
        .for_each(|(i, (x_right, x_left))| {
            debug_assert_eq!(
                (i, x_right, x_left, *x_right + *x_left),
                (i, x_right, x_left, F::ZERO)
            );
            output &= *x_right + *x_left == F::ZERO
        });

    debug_assert!(output);
    // final check:
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    // add masks to left, i.e. "0",
    let p_left = polynomial_compression(share_of_u.0, &F::ONE, r_f, &e_p[0..r_f + 1], &r_left);
    let q_left = polynomial_compression(share_of_v.0, &F::ONE, r_f, &e_p[0..r_f + 1], &r_left);
    let p_right = polynomial_compression(share_of_u.1, &F::ZERO, r_f, &e_p[0..r_f + 1], &r_right);
    let q_right = polynomial_compression(share_of_v.1, &F::ZERO, r_f, &e_p[0..r_f + 1], &r_right);

    // reveal q(r), p(r) and g(r) and verify p(r)*g(r)=G(r)
    // todo
    // dummy debug verify:
    debug_assert_eq!(
        (p_left + p_right) * (q_left + q_right),
        g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1]
    );
    output &= (p_left + p_right) * (q_left + q_right)
        == g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1];

    Ok(output)
}

/// replaces `g_previous(r)` with `g_previous(r)-sum_(x in evaluation_points) g_current(x)`
/// We only include `g(x)` for evaluation points `x` that correspond to an actual `v`, `u` values
/// These `g(x)` are only the first half of points used to represent `g`,
/// the second half of points guarantee that `g` has degree `2*recursion_factor-1`
/// the sums are later verified to be zero which is one of the two equations checked by the verifiers
fn compute_sums_gr_gm<F>(proof: &NIDZKP<F>, g_r: &mut [F]) -> ()
where
    F: Field,
{
    // compute sum of proofs
    // only sum the first `recursion_factor = proof.len()/2` many points,
    // the other points are just to ensure the degree of g is `2*recursion_factor-1`
    g_r.iter_mut()
        .zip(proof.proofs.iter())
        .for_each(|(x, proof)| {
            *x -= proof[0..proof.len() >> 1]
                .iter()
                .fold(F::ZERO, |acc, x| acc + *x)
        });

    // remove the mask from the sum for the last proof,
    // i.e. values at index 0 (corresponding to `u_0`, `v_0`)
    g_r[proof.proofs.len() - 1] += proof.proofs[proof.proofs.len() - 1][0];
}

fn compute_g_r<F>(
    proof: &NIDZKP<F>,
    out: &F,
    random_points: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g_r: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(proof.proofs.len() + 1, g_r.len());
    debug_assert_eq!(evaluation_points.len(), 2 * recursion_factor + 2);
    debug_assert_eq!(random_points.len(), proof.proofs.len());

    let mut iter_right = g_r.iter_mut();
    *iter_right.next().unwrap() = out.clone();
    iter_right
        .zip(proof.proofs.iter())
        .zip(random_points.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points[0..g.len()],
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });
}

/// the `polynomial_compression` function
/// given a vector `share`,
/// recursively shrink the vector
/// by treating chunks of the vector as degree `recursion_factor -1` polynomials
/// and evaluate the polynomial on the `random_points`
/// until each `random_point` has been used and `share` collapsed to a single element
/// the polynomials are represented by points on the polynomial at the `evaluation_points`
/// mask is the `0` point during the last recursion
fn polynomial_compression<F>(share: &mut Vec<F>, mask: &F, r_f: usize, e_p: &[F], r_p: &[F]) -> F
where
    F: Field + Invert,
{
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - r_f.leading_zeros() + 1);
    debug_assert_eq!(e_p.len(), r_f + 1);

    // iterate over recursions
    for r in r_p.iter().take(r_p.len() - 1) {
        // check whether there are too many random points,
        // which leads to unnecessary compression
        debug_assert!(share.len() > r_f);

        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = share.len() % r_f;
        if coset != 0 {
            share.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials in `share`
        let s = share.len() / r_f;

        let mut share_new = vec![F::ONE; s];

        // `share` is split into chunks of size `recursion_factor`
        // to represent the polynomials
        // which are represented by `recursion_factor` many values in `share`
        // we then Lagrange evaluate it on the next `random_point` to compute new elements in `share`
        share_new
            .iter_mut()
            .zip(share.chunks(r_f))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &e_p[0..r_f],
                    chunk,
                    std::slice::from_ref(r),
                    std::slice::from_mut(u),
                );
            });
        // reassign new `share` for next iteration
        *share = share_new;
        share.truncate(s);
    }

    debug_assert!(share.len() <= r_f);

    // final shares, compute output
    let mut output = F::ONE;

    let final_share = {
        let mut vec = Vec::<F>::with_capacity(share.len() + 1);
        // add prss mask
        vec.push(*mask);
        // copy rest
        vec.extend(&*share);
        vec
    };
    lagrange_evaluation(
        &e_p[0..final_share.len()],
        &final_share,
        std::slice::from_ref(r_p.last().unwrap()),
        std::slice::from_mut(&mut output),
    );

    return output;
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
fn compute_summand_of_g<F>(
    u: &[F],
    v: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(evaluation_points.len(), 2usize * recursion_factor);
    debug_assert_eq!(evaluation_points.len(), g.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * recursion_factor];

    // compute first recursion factor many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(recursion_factor)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        u,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        v,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// computes random challenge `r` from `proof_right`
/// since the verifier has only access to `proof_right`,
/// further, he computes all `r` at once
/// he needs to receive `fiat_shamir(proof_left)` from the other verifier
/// `r` is computed has `fiat_shamir(proof_left)+fiat_shamir(proof_right)`
/// `compute_r_prover` takes as input `r` and adds the generated `r` to input `r`
// todo: make it async
fn compute_r_verifier<F>(proof_right: &NIDZKP<F>, r: &mut [F]) -> ()
where
    F: Field,
{
    debug_assert_eq!(proof_right.proofs.len(), r.len());
    r.iter_mut()
        .zip(proof_right.proofs.iter())
        .for_each(|(r, proof)| {
            fiat_shamir(proof, r);

            // send and receive r
            // todo replace `F::ZERO` with actual received `r`
            let r_received = F::ZERO;
            *r += r_received;
        });
}

/// computes random challenge `r` from `proof_part_left` and `proof_part_right`
/// since only the prover has access to both parts, only he can compute `r` this way
/// further, the prover computes `r` one by one rather than all `r` at once
/// `r` is computed has `fiat_shamir(proof_part_left)+fiat_shamir(proof_part_right)`
/// `compute_r_prover` takes as input `r` and adds the generated `r` to input `r`
fn compute_r_prover<F>(proof_left: &[F], proof_right: &[F], r: &mut F) -> ()
where
    F: Field,
{
    fiat_shamir(proof_left, r);
    fiat_shamir(proof_right, r);
}

/// the Fiat-Shamir core function
/// it takes a commitment, which is for `NIDZKP` the actual proof
/// and computes a vector of random points by hashing the individual proofs parts
/// this function only computes `r` for a single proof part
/// `fiat_shamir` takes an input `r` and adds the generated value to `r`
fn fiat_shamir<F>(proof: &[F], r: &mut F) -> ()
where
    F: Field,
{
    // serialize proof const SIZE: usize = <F as Serializable>::Size::USIZE;
    let mut ikm = Vec::<u8>::with_capacity(proof.len() * <F as Serializable>::Size::USIZE);
    proof.iter().for_each(|f| {
        let mut buf = vec![0u8; <F as Serializable>::Size::USIZE];
        f.serialize(GenericArray::from_mut_slice(&mut buf));
        ikm.extend(buf)
    });

    // compute `r` from `hash` of the proof
    let hk = Hkdf::<Sha256>::new(None, &ikm);
    // ideally we would generate `hash` as a `[u8;F::Size]` and `deserialize` it to generate `r`
    // however, deserialize might fail for some fields so we use `from_random_128` instead
    // therefore fields beyond `F::Size()>16` don't further reduce the cheating probability of the prover
    let mut hash = [0u8; 16];
    // hash length is a valid length so expand does not fail
    hk.expand(&[], &mut hash).unwrap();
    *r += F::from_random_u128(u128::from_le_bytes(hash));
}

#[cfg(all(test, unit_test))]

mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::ec_prime_field::Fp25519,
        protocol::ipa_prf::malicious_security::quadratic_proofs::{
            generate_proof, polynomial_compression, verify_proof,
        },
        secret_sharing::SharedValue,
    };

    #[test]
    fn polynomial_compression_test() {
        let recursion_factor = 2usize;
        let mut rng = thread_rng();
        let evaluation_points = (0..recursion_factor + 1)
            .map(|i| Fp25519::try_from(i as u128).unwrap())
            .collect::<Vec<Fp25519>>();
        // random mask
        let mask = rng.gen::<Fp25519>();
        // random points (i.e. verifier challenge points)
        let mut r = vec![Fp25519::ZERO; 3];
        r.iter_mut().for_each(|x| *x = rng.gen());
        // random shares of u
        let u = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        u.0.iter_mut().for_each(|x| *x = rng.gen());
        u.0.iter_mut().for_each(|x| *x = rng.gen());

        // u in the clear
        let mut u_in_the_clear =
            u.0.iter()
                .zip(u.1.iter())
                .map(|(u0, u1)| *u0 + *u1)
                .collect::<Vec<Fp25519>>();

        // compute reconstruct on shares
        let p0 = polynomial_compression(u.0, &mask, recursion_factor, &evaluation_points, &r);
        let p1 = polynomial_compression(
            u.1,
            &Fp25519::ZERO,
            recursion_factor,
            &evaluation_points,
            &r,
        );

        // compute it on the clear, left and right is supposed to be the same
        let p = polynomial_compression(
            &mut u_in_the_clear,
            &mask,
            recursion_factor,
            &evaluation_points,
            &r,
        );

        assert_eq!((mask, p0 + p1), (mask, p));
    }

    #[test]
    fn debug_test() {
        let recursion_factor = 2usize;
        let mut rng = thread_rng();
        let u = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        let v = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        u.1.iter_mut().for_each(|x| *x = rng.gen());
        v.1.iter_mut().for_each(|x| *x = rng.gen());
        u.0.iter_mut().for_each(|x| *x = rng.gen());
        v.0.iter_mut().for_each(|x| *x = rng.gen());
        let u_in_the_clear =
            u.0.iter()
                .zip(u.1.iter())
                .map(|(u0, u1)| *u0 + *u1)
                .collect::<Vec<Fp25519>>();
        let v_in_the_clear =
            v.0.iter()
                .zip(v.1.iter())
                .map(|(v0, v1)| *v0 + *v1)
                .collect::<Vec<Fp25519>>();
        let out = u_in_the_clear
            .iter()
            .zip(v_in_the_clear.iter())
            .fold(Fp25519::ZERO, |acc, (u, v)| acc + (*u * *v));
        let proof = generate_proof(
            &mut u_in_the_clear.clone(),
            &mut v_in_the_clear.clone(),
            recursion_factor,
        );

        assert!(verify_proof(&proof, &out, u, v).unwrap());
    }
}
