use futures_util::future;
use generic_array::{ArrayLength, GenericArray};

use crate::{
    ff::{Error, Field, Invert},
    protocol::{context::Context, prss::SharedRandomness, RecordId},
    secret_sharing::replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
};

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the vector length of `g_left` determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used Vec instead of GenArray)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    proofs: Vec<Vec<F>>,
}

/// generates recursive proof for sum_i u_i*v_i = out over field F
/// `recursion_factor` determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
/// this proof is sent to the party on the left
/// it is therefore the "right proof" of the party on the left
/// the left part of the proof is implicitly generated by the party on the right using left prss during verification
pub fn generate_proof<F>(
    //ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    recursion_factor: usize,
) -> NIDZKP<F>
where
    F: Field + Invert,
    //C: Context,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    let mut output = NIDZKP {
        proofs: Vec::with_capacity(1),
    };

    // record counter
    let mut counter = 0usize;

    // generate evaluation points `(F::0..F::(i)..)`
    let evaluation_points = (0..2 * recursion_factor + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // iterate over recursions
    while u.len() > recursion_factor {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        u.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));
        v.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = u.len() / recursion_factor;

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * recursion_factor];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(recursion_factor)
            .zip(v.chunks(recursion_factor))
            .for_each(|(u, v)| {
                compute_summand_of_g(
                    u,
                    v,
                    recursion_factor,
                    &evaluation_points[0..2 * recursion_factor],
                    &mut g,
                )
            });

        // #[cfg(debug_assertions)]
        // {
        //     let sum_uv = u
        //         .iter()
        //         .zip(v.iter())
        //         .fold(F::ZERO, |acc, (u, v)| acc + *u * *v);
        //     let sum_g = g[0..recursion_factor]
        //         .iter()
        //         .fold(F::ZERO, |acc, g| acc + *g);
        //     debug_assert_eq!(sum_uv, sum_g);
        //     // check interpolation
        //     if !output.proofs.is_empty() {
        //         let mut g_r_previous = F::ONE;
        //         lagrange_evaluation(
        //             &evaluation_points[0..2 * recursion_factor],
        //             &output.proofs.last().unwrap(),
        //             std::slice::from_ref(&F::ZERO),
        //             std::slice::from_mut(&mut g_r_previous),
        //         );
        //         debug_assert_eq!(g_r_previous, output.proofs.last().unwrap()[0]);
        //         debug_assert_eq!(g_r_previous, sum_uv);
        //     }
        // }

        // secret share g using prss_right
        // todo

        // add secret share of g to the proofs
        // todo
        g.iter_mut().for_each(|x| *x += F::ZERO - F::ONE);
        output.proofs.push(g);

        // compute random point r via `Fiat-Shamir` hash
        // generate r as hash(g+prss_right) xor hash(prss_right)
        // r is not allowed to be in evaluation_points[0..recursion_factor]
        // todo
        let r = F::ZERO;

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; s];
        u_new
            .iter_mut()
            .zip(u.chunks(recursion_factor))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(u),
                )
            });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; s];
        v_new
            .iter_mut()
            .zip(v.chunks(recursion_factor))
            .for_each(|(v, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(v),
                )
            });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(s);
        v.truncate(s);
    }

    // define last g
    // since we add masks, the degree of g might be larger
    let mut final_g = vec![F::ZERO; 2 * u.len() + 2];

    // generate final `evaluation_points`
    // generate mask p[0] from prss_right and append to u
    // generate mask q[0] from prss_right and append to v
    // todo
    let (final_u, final_v) = {
        let mut vec_u = Vec::<F>::with_capacity(u.len() + 1);
        let mut vec_v = Vec::<F>::with_capacity(u.len() + 1);
        // add prss masks
        // todo
        vec_u.push(F::ONE);
        vec_v.push(F::ONE);
        // copy rest
        vec_u.extend(&*u);
        vec_v.extend(&*v);
        (vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(
        &final_u,
        &final_v,
        final_u.len(),
        &evaluation_points[..2 * u.len() + 2],
        &mut final_g,
    );

    // #[cfg(debug_assertions)]
    // {
    //     let sum_uv = final_u
    //         .iter()
    //         .zip(final_v.iter())
    //         .fold(F::ZERO, |acc, (u, v)| acc + *u * *v);
    //     let sum_g = final_g[0..final_u.len()]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     debug_assert_eq!(sum_uv, sum_g);
    //
    //     let sum_one = output.proofs[1][0..recursion_factor]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     assert_eq!(output.proofs[0][0],sum_one);
    //
    //     let length = output.proofs.last().unwrap().len()>>1;
    //     let mut g_r_previous = F::ONE;
    //     lagrange_evaluation(
    //         &evaluation_points[0..2*recursion_factor],
    //         &output.proofs[output.proofs.len()-2],
    //         std::slice::from_ref(&F::ZERO),
    //         std::slice::from_mut(&mut g_r_previous),
    //     );
    //     debug_assert_eq!(g_r_previous,output.proofs[output.proofs.len()-2][0]);
    //     let sum_last = output.proofs.last().unwrap()[0..length]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     assert_eq!(g_r_previous,sum_last);
    // }
    // add secret share of g to the proofs
    // todo
    final_g.iter_mut().for_each(|x| *x += F::ZERO - F::ONE);

    output.proofs.push(final_g);

    return output;
}

/// verify proof
/// needs interaction to compute the hashes, i.e. random points
// need to change it to async once prss is incorporated
// todo
pub fn verify_proof<F>(
    //ctx: C,
    proof_right: &NIDZKP<F>,
    out: (&F, &F),
    share_of_u: (&mut Vec<F>, &mut Vec<F>),
    share_of_v: (&mut Vec<F>, &mut Vec<F>),
) -> Result<bool, Error>
where
    //C: Context,
    F: Field + Invert,
{
    // setup output
    let mut output = true;

    // check that there is at least one recursion
    debug_assert!(proof_right.proofs.len() > 1);
    // compute recursion factor
    let recursion_factor = proof_right.proofs[0].len() >> 1;

    // generate evaluation points `(F::0..F::(i)..)`
    let evaluation_points = (0..2 * recursion_factor + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // compute left part of the proof
    // todo
    let proof_left = &mut NIDZKP {
        proofs: Vec::with_capacity(proof_right.proofs.len()),
    };
    proof_right
        .proofs
        .iter()
        // add prss value to proof
        // todo
        .for_each(|x| proof_left.proofs.push(vec![F::ONE; x.len()]));

    // first, compute r's using hashing and out
    // todo
    let r_right = vec![F::ZERO; proof_right.proofs.len()];
    let r_left = vec![F::ZERO; proof_left.proofs.len()];
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len() + 1];
    let mut g_r_left = vec![F::ONE; proof_left.proofs.len() + 1];

    // then compute g_r using lagrange_evaluation
    for (r, g_r, proof) in [
        (&r_right, &mut g_r_right, proof_right),
        (&r_left, &mut g_r_left, proof_left),
    ] {
        compute_g_r(proof, out.1, r, recursion_factor, &evaluation_points, g_r);

        // compute `g_r = g_r-sum g(x)`
        compute_sums_gr_gm(proof, g_r);
    }

    // zero test
    // check that all sums `g_r == 0`
    // todo
    // dummy debug zero test:
    g_r_right[0..g_r_right.len() - 1]
        .iter()
        .zip(g_r_right[0..g_r_right.len() - 1].iter())
        .enumerate()
        .for_each(|(i, (x_right, x_left))| {
            debug_assert_eq!((i, *x_right), (i, *x_left));
            output &= *x_right - *x_left == F::ZERO
        });

    debug_assert!(output);
    // final check:
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    let (p, q) = reconstruct_p_and_q(
        share_of_u,
        share_of_v,
        (&F::ONE, &F::ONE),
        recursion_factor,
        &evaluation_points,
        (&r_left[..], &r_right[..]),
    );
    // reveal q(r), p(r) and g(r) and verify p(r)*g(r)=G(r)
    // todo
    // dummy debug verify:
    debug_assert_eq!(
        (p.left() + p.right()) * (q.left() + q.right()),
        g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1]
    );
    output &= (p.left() + p.right()) * (q.left() + q.right())
        == g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1];

    Ok(output)
}

/// replaces `g_previous(r)` with `g_previous(r)-sum_(x in evaluation_points) g_current(x)`
/// We only include `g(x)` for evaluation points `x` that correspond to an actual `v`, `u` values
/// These `g(x)` are only the first half of points used to represent `g`,
/// the second half of points guarantee that `g` has degree `2*recursion_factor-1`
/// the sums are later verified to be zero which is one of the two equations checked by the verifiers
pub fn compute_sums_gr_gm<F>(proof: &NIDZKP<F>, g_r: &mut [F]) -> ()
where
    F: Field,
{
    // compute sum of proofs
    // only sum the first `recursion_factor = proof.len()/2` many points,
    // the other points are just to ensure the degree of g is `2*recursion_factor-1`
    g_r.iter_mut()
        .zip(proof.proofs.iter())
        .for_each(|(x, proof)| {
            *x -= proof[0..proof.len() >> 1]
                .iter()
                .fold(F::ZERO, |acc, x| acc + *x)
        });

    // remove the mask from the sum for the last proof,
    // i.e. values at index 0 (corresponding to `u_0`, `v_0`)
    g_r[proof.proofs.len() - 1] += proof.proofs[proof.proofs.len() - 1][0];
}

pub fn compute_g_r<F>(
    proof: &NIDZKP<F>,
    out: &F,
    random_points: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g_r: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(proof.proofs.len() + 1, g_r.len());
    debug_assert_eq!(evaluation_points.len(), 2 * recursion_factor + 2);
    debug_assert_eq!(random_points.len(), proof.proofs.len());

    let mut iter_right = g_r.iter_mut();
    *iter_right.next().unwrap() = out.clone();
    iter_right
        .zip(proof.proofs.iter())
        .zip(random_points.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points[0..g.len()],
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });
}

pub fn reconstruct_p_and_q<F>(
    share_of_u: (&mut Vec<F>, &mut Vec<F>),
    share_of_v: (&mut Vec<F>, &mut Vec<F>),
    masks: (&F, &F),
    recursion_factor: usize,
    evaluation_points: &[F],
    random_points: (&[F], &[F]),
) -> (AdditiveShare<F>, AdditiveShare<F>)
where
    F: Field + Invert,
{
    // check length
    debug_assert_eq!(share_of_u.0.len(), share_of_v.1.len());
    debug_assert_eq!(share_of_u.0.len(), share_of_u.1.len());
    debug_assert_eq!(share_of_v.0.len(), share_of_v.1.len());
    debug_assert_eq!(random_points.0.len(), random_points.1.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    let mut p_r = (&mut F::ONE, &mut F::ONE);
    let mut q_r = (&mut F::ONE, &mut F::ONE);

    // iterate over recursions
    for r in random_points
        .0
        .iter()
        .zip(random_points.1.iter())
        .take(random_points.0.len() - 1)
    {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = share_of_u.0.len() % recursion_factor;
        if coset != 0 {
            share_of_u.0.extend(std::iter::repeat(F::ZERO).take(coset));
            share_of_u.1.extend(std::iter::repeat(F::ZERO).take(coset));
            share_of_v.0.extend(std::iter::repeat(F::ZERO).take(coset));
            share_of_v.1.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = share_of_u.0.len() / recursion_factor;

        // compute u_new, v_new for next iteration
        for (share, r) in [
            (&mut *share_of_u.0, r.0),
            (&mut *share_of_u.1, r.1),
            (&mut *share_of_v.0, r.0),
            (&mut *share_of_v.1, r.1),
        ] {
            // compute `p(r)` when `share = share_of_u`
            // compute `q(r)` when `share = share_of_v`

            let mut share_new = vec![F::ONE; s];

            // `share` is split into chunks of size `recursion_factor`
            // to represent the polynomials `p`, `q`
            // which are represented by `recursion_factor` many values in `u`, `v`
            // we then Lagrange evaluate `p`, `q` to compute `p(r)`, `q(r)`
            share_new
                .iter_mut()
                .zip(share.chunks(recursion_factor))
                .for_each(|(u, chunk)| {
                    lagrange_evaluation(
                        &evaluation_points[0..recursion_factor],
                        chunk,
                        std::slice::from_ref(r),
                        std::slice::from_mut(u),
                    );
                });
            // reassign u_new, v_new for next iteration
            *share = share_new;
            share.truncate(s);
        }
    }
    // final shares, compute p, q
    for (share, mask, p_or_q, r) in [
        (
            share_of_u.0,
            masks.0,
            &mut *p_r.0,
            random_points.0[random_points.0.len() - 1],
        ),
        (
            share_of_v.0,
            masks.1,
            &mut *q_r.0,
            random_points.0[random_points.0.len() - 1],
        ),
        (
            share_of_u.1,
            &F::ZERO,
            &mut *p_r.1,
            random_points.1[random_points.1.len() - 1],
        ),
        (
            share_of_v.1,
            &F::ZERO,
            &mut *q_r.1,
            random_points.1[random_points.1.len() - 1],
        ),
    ] {
        let final_share = {
            let mut vec = Vec::<F>::with_capacity(share.len() + 1);
            // add prss mask
            vec.push(*mask);
            // copy rest
            vec.extend(&*share);
            vec
        };
        lagrange_evaluation(
            &evaluation_points[0..final_share.len()],
            &final_share,
            std::slice::from_ref(&r),
            std::slice::from_mut(p_or_q),
        );
    }

    return (
        AdditiveShare::new(*p_r.0, *p_r.1),
        AdditiveShare::new(*q_r.0, *q_r.1),
    );
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
fn compute_summand_of_g<F>(
    u: &[F],
    v: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(evaluation_points.len(), 2usize * recursion_factor);
    debug_assert_eq!(evaluation_points.len(), g.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * recursion_factor];

    // compute first recursion factor many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(recursion_factor)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        u,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        v,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// lagrange evaluation
/// given points `(x_0,y_0),...,(x_n,y_0)` on a polynomial `p`
/// and points `p_0,...,p_m`
/// compute `result_0=result_0*p(p_0),...,result_m=result_m*p(p_m)`
/// It uses the lagrange method to compute the points `https://en.wikipedia.org/wiki/Lagrange_polynomial`
/// further, rather than outputting `p(p_k)`, we set `result_k=result_k*p(p_k)`
/// which fits better to how we use `p(p_k)`
pub fn lagrange_evaluation<F>(x: &[F], y: &[F], p: &[F], result: &mut [F]) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(x.len(), y.len());
    debug_assert_eq!(p.len(), result.len());
    #[cfg(debug_assertions)]
    {
        for i in 0..x.len() {
            for j in 0..x.len() {
                debug_assert_eq!((i, j, x[i] - x[j] != F::ZERO || j == i), (i, j, true))
            }
        }
    }

    // compute denominators:
    let mut denominator = vec![F::ONE; x.len()];
    for i in 0..x.len() {
        if i > 0 {
            for j in 0..i {
                denominator[i] *= x[i] - x[j];
            }
        }
        if i + 1 < x.len() {
            for j in i + 1..x.len() {
                denominator[i] *= x[i] - x[j];
            }
        }
        denominator[i] = denominator[i].invert();
    }

    for k in 0..p.len() {
        // evaluate polynomial on point p_k, i.e. compute `p(p_k)` use Lagrange formula
        let mut sum = F::ZERO;
        for i in 0..x.len() {
            let mut basis_polynomial = denominator[i] * y[i];
            if i > 0 {
                for j in 0..i {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            if i + 1 < x.len() {
                for j in i + 1..x.len() {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            sum += basis_polynomial;
        }
        // compute "result_k = result_k * p(p_k)"
        result[k] *= sum;
    }
}

#[cfg(all(test, unit_test))]

mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::{ec_prime_field::Fp25519, FieldType::Fp31},
        protocol::ipa_prf::malicious_security::quadratic_proofs::{
            generate_proof, lagrange_evaluation, verify_proof,
        },
        secret_sharing::SharedValue,
    };

    #[test]
    fn lagrange_evaluation_fp25519() {
        let mut rng = thread_rng();
        let evaluation_points_size = rng.gen::<usize>() % 100;
        let mut evaluation_points = vec![Fp25519::ONE; evaluation_points_size];
        evaluation_points
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        let mut y_values = vec![Fp25519::ONE; evaluation_points_size];
        y_values.iter_mut().for_each(|y| *y = rng.gen::<Fp25519>());
        let mut evaluated_y = vec![Fp25519::ONE; evaluation_points_size];
        lagrange_evaluation(
            &evaluation_points,
            &y_values,
            &evaluation_points,
            &mut evaluated_y,
        );

        // test evaluation at interpolation points
        assert_eq!(evaluated_y, y_values);

        // sample random polynomial in monomial form of degree `evaluation_points_size`
        let mut polynomial = vec![Fp25519::ONE; evaluation_points_size];
        polynomial
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        // add random point to evaluation points
        evaluation_points.push(rng.gen::<Fp25519>());

        // evaluate polynomial at evaluation_points
        let mut y_values = vec![Fp25519::ZERO; evaluation_points_size + 1];
        evaluation_points.iter().for_each(|x_value| {
            let mut base = Fp25519::ONE;
            polynomial.iter().for_each(|coefficient| {
                y_values.iter_mut().for_each(|y| *y = *coefficient * base);
                base *= *x_value
            })
        });

        // lagrange evaluate at random point
        evaluated_y[0] = Fp25519::ONE;
        lagrange_evaluation(
            &evaluation_points[0..evaluation_points_size],
            &y_values[0..evaluation_points_size],
            std::slice::from_ref(&evaluation_points[evaluation_points_size]),
            std::slice::from_mut(&mut evaluated_y[0]),
        );

        // check equality
        assert_eq!(y_values[evaluation_points_size], evaluated_y[0]);
    }

    #[test]
    fn debug_test() {
        let recursion_factor = 2usize;
        let mut rng = thread_rng();
        let u = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        let v = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        u.1.iter_mut().for_each(|x| *x = rng.gen());
        v.1.iter_mut().for_each(|x| *x = rng.gen());
        let out_left =
            u.0.iter()
                .zip(v.0.iter())
                .fold(Fp25519::ZERO, |acc, (u, v)| acc + (*u * *v));
        let out_right =
            u.1.iter()
                .zip(v.1.iter())
                .fold(Fp25519::ZERO, |acc, (u, v)| acc + (*u * *v));
        let proof = generate_proof(&mut u.1.clone(), &mut v.1.clone(), recursion_factor);
        // let sum_right = proof.proofs.clone()[0][0..recursion_factor]
        //     .iter()
        //     .fold(Fp25519::ZERO, |acc, g| acc + *g);
        // assert_eq!(out_right, sum_right);
        // let mut g_r_one = Fp25519::ONE;
        // let evaluation_points = (0..2 * recursion_factor + 2)
        //     .map(|i| Fp25519::try_from(i as u128).unwrap())
        //     .collect::<Vec<Fp25519>>();
        // lagrange_evaluation(
        //     &evaluation_points[0..2 * recursion_factor],
        //     &proof.proofs[0],
        //     std::slice::from_ref(&Fp25519::ZERO),
        //     std::slice::from_mut(&mut g_r_one),
        // );
        // assert_eq!(g_r_one, proof.proofs[0][0]);
        // let sum_one = proof.proofs.clone()[1][0..recursion_factor]
        //     .iter()
        //     .fold(Fp25519::ZERO, |acc, g| acc + *g);
        // assert_eq!(g_r_one, sum_one);

        // let length = proof.proofs.last().unwrap().len()>>1;
        // let mut g_r_previous = Fp25519::ONE;
        // lagrange_evaluation(
        //     &evaluation_points[0..2*recursion_factor],
        //     &proof.proofs[proof.proofs.len()-2],
        //     std::slice::from_ref(&Fp25519::ZERO),
        //     std::slice::from_mut(&mut g_r_previous),
        // );
        // debug_assert_eq!(g_r_previous,proof.proofs[proof.proofs.len()-2][0]);
        // let sum_last = proof.proofs.last().unwrap()[0..length]
        //     .iter()
        //     .fold(Fp25519::ZERO, |acc, g| acc + *g);
        // assert_eq!(g_r_previous,sum_last);

        assert!(verify_proof(&proof, (&out_left, &out_right), u, v).unwrap());
    }
}
