use futures::StreamExt;
use futures_util::{stream, TryStreamExt};
use ipa_macros::Step;

use crate::{
    error::Error,
    ff::{Field, Invert},
    helpers::{Direction, ReceivingEnd, SendingEnd},
    protocol::{
        basics::validate_replicated_shares::validate_sum_to_zero,
        context::Context,
        ipa_prf::malicious_security::{
            fiat_shamir::{fiat_shamir_prover, fiat_shamir_verifier},
            lagrange::{
                compute_lagrange_base, compute_lagrange_denominator, generate_evaluation_points,
                lagrange_evaluation, lagrange_evaluation_precomputed,
            },
        },
        prss::SharedRandomness,
        RecordId,
    },
    seq_join::seq_join,
};

#[derive(Step)]
pub(crate) enum Step {
    HashFromLeft,
    HashFromRight,
    PQFromLeft,
    TwoOutOfTwoZeroCheck,
}

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the length of the left share, `g_left`, determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used `Vec` instead of `GenericArray`)
/// the "left proof" also contains non-zero masks, `mask_p` and `mask_q`.
/// For the "right proof" both masks are zero.
///
/// Proofs that are sent to other parties have mask that are always zero and therefore don't need to be sent.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    pub(crate) proofs: Vec<Vec<F>>,
    pub(crate) mask_p: F,
    pub(crate) mask_q: F,
}

/// generates recursive proof for `sum_i u_i*v_i = out` over field `F`
///
/// `r_f`, i.e. recursion factor, determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
///
/// the output on the right needs to be sent to the party on the left
/// it is therefore the "right share" of the party on the left
///
/// the left part of the output is the "left share" of the proof generated by the party on the right
/// this part is generated using PRSS and does not need to be sent,
/// it remains with the party and is the input `proof_left` to the proof verification
/// the outputs includes the two masks for the proofs, i.e. `mask_p`, `mask_q`
///
/// This function uses `ctx` for generating random values using PRSS
/// and sending the right part of the proof to the left
///
/// # Errors
/// propagates errors from send and receive
///
/// # Panics
/// Does not panic
pub async fn generate_proof<C, F>(
    ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    r_f: usize,
) -> Result<(NIDZKP<F>, NIDZKP<F>), Error>
where
    C: Context,
    F: Field + Invert,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - r_f.leading_zeros() + 1);
    // record, used as counter for PRSS
    let mut record = 0usize;

    // proof length
    #[allow(
        clippy::cast_possible_truncation,
        clippy::cast_sign_loss,
        clippy::cast_precision_loss
    )]
    let proof_length = (u.len() as f64).log(r_f as f64).ceil() as usize + 1usize;
    // get masks from PRSS
    let mask_p = ctx.prss().generate_fields(RecordId::from(record)); //(F::ONE, F::ONE);
    record += 1;
    let mask_q = ctx.prss().generate_fields(RecordId::from(record));
    // proof from the prover on the left, i.e. generated via `PRSS.left` rather than receiving it from the left
    let mut output_left = NIDZKP {
        proofs: Vec::with_capacity(proof_length),
        // set mask p(0) from `PRSS.left`
        mask_p: mask_p.0,
        // set mask q(0) from `PRSS.left`
        mask_q: mask_q.0,
    };
    // right part of this helpers own proof, to be sent to the left
    let mut own_proof_right = NIDZKP {
        proofs: Vec::with_capacity(proof_length),
        mask_p: F::ZERO,
        mask_q: F::ZERO,
    };

    // precomputation for Lagrange
    let mut e_p = vec![F::ZERO; 2 * r_f];
    generate_evaluation_points(&mut e_p);
    // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
    let mut ds = vec![F::ONE; r_f];
    compute_lagrange_denominator(&e_p[0..r_f], &mut ds);
    let mut base = vec![vec![F::ONE; r_f]; r_f];
    compute_lagrange_base(&e_p[r_f..2 * r_f], &e_p[0..r_f], &ds, &mut base);

    // iterate over recursions
    while u.len() >= r_f {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = u.len() % r_f;
        if coset != 0 {
            u.extend(std::iter::repeat(F::ZERO).take(coset));
            v.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let length = u.len() / r_f;

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * r_f];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(r_f)
            .zip(v.chunks(r_f))
            .for_each(|(u, v)| compute_summand_of_g(u, v, r_f, &base, &mut g));

        // compute secret share g_left (i.e. part of the proof recovered by right party) using prss_right
        let mut output_g_left = Vec::<F>::with_capacity(g.len());
        // `own_g_left` is needed for hash, i.e. "Fiat-Shamir" `r`:
        let mut own_g_left = Vec::<F>::with_capacity(g.len());
        for g in &mut g {
            // get prss
            record += 1;
            let (left, right) = ctx.prss().generate_fields(RecordId::from(record));
            // push `PRSS.left` to `output_g_left`
            output_g_left.push(left);
            // own_g_left:
            own_g_left.push(right);
            // compute secret share `own_g_right` by computing `own_g_right=g-own_g_left`
            // we just need to subtract `own_g_left`, which comes from `PRSS.right`
            *g -= right;
        }

        // compute random point `r` via `Fiat-Shamir` hash
        // generate `r` as `hash(g_right) + hash(g_left)`
        let r = fiat_shamir_prover(&g, &own_g_left);

        // add `g` to proofs
        output_left.proofs.push(output_g_left);
        own_proof_right.proofs.push(g);

        // precompute Lagrange base for `r`
        let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
        compute_lagrange_base(std::slice::from_ref(&r), &e_p[0..r_f], &ds, &mut base_r);

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; length];
        u_new.iter_mut().zip(u.chunks(r_f)).for_each(|(u, chunk)| {
            lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(u));
        });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; length];
        v_new.iter_mut().zip(v.chunks(r_f)).for_each(|(v, chunk)| {
            lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(v));
        });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(length);
        v.truncate(length);
    }

    // define last g
    let mut final_g = vec![F::ZERO; 2 * r_f];

    // generate final `evaluation_points`
    let (final_u, final_v) = {
        let mut vec_u = Vec::<F>::with_capacity(r_f);
        let mut vec_v = Vec::<F>::with_capacity(r_f);
        // add masks from `PRSS.right` generated at the beginning of this function
        vec_u.push(mask_p.1);
        vec_v.push(mask_q.1);
        // copy rest
        vec_u.extend(&*u);
        vec_v.extend(&*v);
        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = vec_u.len() % r_f;
        if coset != 0 {
            vec_u.extend(std::iter::repeat(F::ZERO).take(coset));
            vec_v.extend(std::iter::repeat(F::ZERO).take(coset));
        }
        (vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(&final_u, &final_v, final_u.len(), &base, &mut final_g);

    // generate last secret share
    let mut output_g_left = Vec::<F>::with_capacity(final_g.len());
    for g in &mut final_g {
        // get prss
        record += 1;
        let (left, right) = ctx.prss().generate_fields(RecordId::from(record));
        // push `PRSS.left` to `output_g_left`
        output_g_left.push(left);
        // compute secret share `own_g_right` by computing `own_g_right=g-own_g_left`
        // we just need to subtract `own_g_left`, which comes from `PRSS.right`
        *g -= right;
    }

    // finalize proofs
    own_proof_right.proofs.push(final_g);
    output_left.proofs.push(output_g_left);

    Ok((
        output_left,
        send_and_receive_proof(ctx, &own_proof_right).await?,
    ))
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
/// invoked by `generate_proof`
fn compute_summand_of_g<F>(u: &[F], v: &[F], r_f: usize, base: &Vec<Vec<F>>, g: &mut [F])
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(base.len(), u.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * r_f];

    // compute first recursion factor many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(r_f)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation_precomputed(u, base, &mut summand_of_g[r_f..2 * r_f]);

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation_precomputed(v, base, &mut summand_of_g[r_f..2 * r_f]);
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// sends proof to left and receive from the right
/// invoked by `generate_proof`
async fn send_and_receive_proof<C, F>(ctx: C, proof_send: &NIDZKP<F>) -> Result<NIDZKP<F>, Error>
where
    C: Context,
    F: Field,
{
    debug_assert!(!proof_send.proofs.is_empty());
    let mut proof_received = proof_send.clone();
    let proof_length = proof_send
        .proofs
        .iter()
        .fold(0usize, |acc, x| acc + x.len());

    // set up context
    let ctx_left = ctx.set_total_records(proof_length);
    // set up channels
    let send_channel_left: &SendingEnd<F> =
        &ctx_left.send_channel(ctx.role().peer(Direction::Left));
    let receive_channel_right: &ReceivingEnd<F> =
        &ctx_left.recv_channel(ctx.role().peer(Direction::Right));

    // send to left, receive on the right
    seq_join(
        ctx_left.active_work(),
        stream::iter(
            proof_send
                .proofs
                .iter()
                .flatten()
                .enumerate()
                .map(|(i, x)| async move {
                    send_channel_left.send(RecordId::from(i), *x).await.unwrap();
                    receive_channel_right
                        .receive(RecordId::from(i))
                        .await
                        .unwrap()
                }),
        ),
    )
    .collect::<Vec<_>>()
    .await
    .iter()
    .zip(proof_received.proofs.iter_mut().flatten())
    .for_each(|(x, y)| *y = *x);

    Ok(proof_received)
}

/// verify proof
///
/// takes left part of the proof from the prover on the left, i.e. `proof_left`
/// which is generated via PRSS from function `generate_proof`
///
/// takes right part of the proof from the prover on the right, i.e. `proof_right`
/// which is sent by the right helper node over the network
///
/// `out` is part of the statement to verify, i.e. `out = sum_i u_i*v_i`
///
/// `share_of_v`, `share_of_u`
/// contains the left shares for the statement proven by the helper party on the left
/// contains the left shares for the statement proven by the helper party on the right
///
/// returns `true` when proof from the helper party on the right verifies,
/// the helper party on the right will output `true`
/// when the proof from the helper party on the left verifies
///
/// needs interaction to compute the hashes, i.e. random points
/// context is used for sending messages, not for generating randomness using PRSS
///
/// # Errors
/// propagates errors from send and receive
/// # Panics
/// when recursion factor exceeds a 128 bit value
pub async fn verify_proof<C, F>(
    ctx: C,
    proof_left: &NIDZKP<F>,
    proof_right: &NIDZKP<F>,
    out: &F,
    share_of_u: (&mut Vec<F>, &mut Vec<F>),
    share_of_v: (&mut Vec<F>, &mut Vec<F>),
) -> Result<(), Error>
where
    C: Context,
    F: Field + Invert + PartialOrd,
{
    // check that there is at least one recursion
    debug_assert!(proof_right.proofs.len() > 1);
    debug_assert_eq!(proof_right.proofs.len(), proof_left.proofs.len());
    // compute recursion factor
    let r_f = proof_right.proofs[0].len() >> 1;

    // evaluation points for Lagrange
    let mut e_p = vec![F::ZERO; 2 * r_f];
    generate_evaluation_points(&mut e_p);

    // declarations
    let mut r_right = vec![F::ZERO; proof_right.proofs.len()];
    let mut r_left = vec![F::ZERO; proof_left.proofs.len()];
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len() + 1];
    let mut g_r_left = vec![F::ONE; proof_left.proofs.len() + 1];

    // compute r_right
    fiat_shamir_verifier(
        ctx.narrow(&Step::HashFromRight),
        proof_right,
        Direction::Right,
        &mut r_right,
        &mut r_left,
    )
    .await?;
    // compute r_left
    fiat_shamir_verifier(
        ctx.narrow(&Step::HashFromLeft),
        proof_left,
        Direction::Left,
        &mut r_left,
        &mut r_right,
    )
    .await?;

    // last `r` is not allowed to be in `evaluation_points[0..recursion_factor]`
    // otherwise inputs are leaked when sending `p(r)`, `q(r)`
    // this reduces min-entropy of r by at most half
    let threshold = F::try_from(r_f as u128 + 1).unwrap();
    if r_right[proof_right.proofs.len() - 1] < threshold {
        r_right[proof_right.proofs.len() - 1] += threshold;
    }
    if r_left[proof_right.proofs.len() - 1] < threshold {
        r_left[proof_right.proofs.len() - 1] += threshold;
    }

    // then compute g_r using lagrange_evaluation
    compute_g_r(proof_right, out, &r_right, r_f, &e_p, &mut g_r_right);
    compute_g_r(proof_left, &F::ZERO, &r_left, r_f, &e_p, &mut g_r_left);

    // compute `g_r = g_r-sum g(x)`
    compute_sums_gr_gm(proof_right, &mut g_r_right);
    compute_sums_gr_gm(proof_left, &mut g_r_left);

    // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
    let mut denominators = vec![F::ONE; r_f];
    compute_lagrange_denominator(&e_p[0..r_f], &mut denominators);
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    // add masks to left, i.e. ".0",
    // compute both, p,q at once since Langrage precomputation is base on `r` which is identical
    let (p_left, q_left) = polynomial_compression(
        share_of_u.0,
        share_of_v.0,
        (&proof_left.mask_p, &proof_left.mask_q),
        r_f,
        &e_p[0..r_f],
        &denominators,
        &r_left,
    );

    debug_assert_eq!((proof_right.mask_p, proof_right.mask_q), (F::ZERO, F::ZERO));
    let (p_right, q_right) = polynomial_compression(
        share_of_u.1,
        share_of_v.1,
        (&proof_right.mask_p, &proof_right.mask_q),
        r_f,
        &e_p[0..r_f],
        &denominators,
        &r_right,
    );

    // compute p(r)*g(r)
    // set up context
    let ctx_new = &(ctx.narrow(&Step::PQFromLeft).set_total_records(2usize));
    // set up channels
    let send_channel: &SendingEnd<F> = &ctx_new.send_channel(ctx.role().peer(Direction::Right));
    let receive_channel: &ReceivingEnd<F> = &ctx_new.recv_channel(ctx.role().peer(Direction::Left));
    let p_q_received = seq_join(
        ctx_new.active_work(),
        stream::iter(
            std::iter::once(p_left)
                .chain(std::iter::once(q_left))
                .enumerate()
                .map(|(i, x)| async move {
                    send_channel.send(RecordId::from(i), x).await?;
                    receive_channel.receive(RecordId::from(i)).await
                }),
        ),
    )
    .try_collect::<Vec<_>>()
    .await?;
    // subtract from `g_r`
    g_r_right[g_r_left.len() - 1] -= (p_right + p_q_received[0]) * (q_right + p_q_received[1]);

    // zero test
    // check that all sums `g_r == 0`
    // swap inputs g_r_left and g_r_right, since prover for left is on the left
    // so we need to send it to the other verifier on the right
    validate_sum_to_zero(
        ctx.narrow(&Step::TwoOutOfTwoZeroCheck),
        &g_r_right,
        &g_r_left,
    )
    .await
}

/// replaces `g_previous(r)` with `g_previous(r)-sum_(x in evaluation_points) g_current(x)`
/// We only include `g(x)` for evaluation points `x` that correspond to an actual `v`, `u` values
/// These `g(x)` are only the first half of points used to represent `g`,
/// the second half of points guarantee that `g` has degree `2*recursion_factor-1`
/// the sums are later verified to be zero which is one of the two equations checked by the verifiers
fn compute_sums_gr_gm<F>(proof: &NIDZKP<F>, g_r: &mut [F])
where
    F: Field,
{
    // compute sum of proofs
    // only sum the first `recursion_factor = proof.len()/2` many points,
    // the other points are just to ensure the degree of g is `2*recursion_factor-1`
    g_r.iter_mut()
        .zip(proof.proofs.iter())
        .for_each(|(x, proof)| {
            *x -= proof[0..proof.len() >> 1]
                .iter()
                .fold(F::ZERO, |acc, x| acc + *x);
        });

    // remove the mask from the sum for the last proof,
    // i.e. values at index 0 (corresponding to `u_0`, `v_0`)
    g_r[proof.proofs.len() - 1] += proof.proofs[proof.proofs.len() - 1][0];
}

fn compute_g_r<F>(
    proof: &NIDZKP<F>,
    out: &F,
    random_points: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g_r: &mut [F],
) where
    F: Field + Invert,
{
    debug_assert_eq!(proof.proofs.len() + 1, g_r.len());
    debug_assert_eq!(evaluation_points.len(), 2 * recursion_factor);
    debug_assert_eq!(random_points.len(), proof.proofs.len());

    let mut iter_right = g_r.iter_mut();
    *iter_right.next().unwrap() = *out;
    iter_right
        .zip(proof.proofs.iter())
        .zip(random_points.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points[0..g.len()],
                g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            );
        });
}

/// the `polynomial_compression` function
/// given two vectors `share_left`, `share_right`,
/// recursively shrink the vector
/// by treating chunks of the vector as degree `recursion_factor -1` polynomials
/// and evaluate the polynomial on the `random_points`
/// until each `random_point` has been used and `share` collapsed to a single element
/// the polynomials are represented by points on the polynomial at the `evaluation_points`
/// mask is the `0` point during the last recursion
fn polynomial_compression<F>(
    share_left: &mut Vec<F>,
    share_right: &mut Vec<F>,
    mask: (&F, &F),
    r_f: usize,
    e_p: &[F],
    denominators: &[F],
    r_p: &[F],
) -> (F, F)
where
    F: Field + Invert,
{
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - r_f.leading_zeros() + 1);
    debug_assert_eq!(e_p.len(), r_f);
    debug_assert_eq!(e_p.len(), denominators.len());
    debug_assert_eq!(share_left.len(), share_right.len());

    // iterate over recursions
    for r in r_p.iter().take(r_p.len() - 1) {
        // check whether there are too many random points,
        // which leads to unnecessary compression
        debug_assert!(share_left.len() >= r_f);

        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = share_left.len() % r_f;
        if coset != 0 {
            share_left.extend(std::iter::repeat(F::ZERO).take(coset));
            share_right.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials in `share`
        let s = share_left.len() / r_f;

        let mut share_new_0 = vec![F::ONE; s];
        let mut share_new_1 = vec![F::ONE; s];

        // precompute Lagrange base for `r`
        let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
        compute_lagrange_base(
            std::slice::from_ref(r),
            &e_p[0..r_f],
            denominators,
            &mut base_r,
        );

        // `share` is split into chunks of size `recursion_factor`
        // to represent the polynomials
        // which are represented by `recursion_factor` many values in `share`
        // we then Lagrange evaluate it on the next `random_point` to compute new elements in `share`
        share_new_0
            .iter_mut()
            .zip(share_left.chunks(r_f))
            .for_each(|(u, chunk)| {
                lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(u));
            });
        share_new_1
            .iter_mut()
            .zip(share_right.chunks(r_f))
            .for_each(|(u, chunk)| {
                lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(u));
            });
        // reassign new `share` for next iteration
        *share_left = share_new_0;
        *share_right = share_new_1;
        share_left.truncate(s);
        share_right.truncate(s);
    }

    debug_assert!(share_left.len() < r_f);

    // final shares, compute output
    let mut output_0 = F::ONE;
    let mut output_1 = F::ONE;

    let (final_share_0, final_share_1) = {
        let mut vec_0 = Vec::<F>::with_capacity(r_f);
        let mut vec_1 = Vec::<F>::with_capacity(r_f);
        // add prss mask
        vec_0.push(*mask.0);
        vec_1.push(*mask.1);
        // copy rest
        vec_0.extend(&*share_left);
        vec_1.extend(&*share_right);
        // fill u and v with zeros such that it is a multiple of the recursion factor
        vec_0.extend(std::iter::repeat(F::ZERO).take(vec_0.len() % r_f));
        vec_1.extend(std::iter::repeat(F::ZERO).take(vec_1.len() % r_f));
        (vec_0, vec_1)
    };

    // precompute Lagrange base for `r`
    let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
    compute_lagrange_base(
        std::slice::from_ref(r_p.last().unwrap()),
        &e_p[0..r_f],
        denominators,
        &mut base_r,
    );

    lagrange_evaluation_precomputed(&final_share_0, &base_r, std::slice::from_mut(&mut output_0));
    lagrange_evaluation_precomputed(&final_share_1, &base_r, std::slice::from_mut(&mut output_1));

    (output_0, output_1)
}

#[cfg(all(test, unit_test))]
mod test {
    use futures::StreamExt;
    use futures_util::stream;
    use ipa_macros::Step;
    use rand::{thread_rng, Rng};

    use crate::{
        ff::ec_prime_field::Fp25519,
        helpers::{Direction, ReceivingEnd, SendingEnd},
        protocol::{
            context::Context,
            ipa_prf::malicious_security::{
                lagrange::compute_lagrange_denominator,
                quadratic_proofs::{generate_proof, polynomial_compression, verify_proof, NIDZKP},
            },
            RecordId,
        },
        secret_sharing::{
            replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
            SharedValue,
        },
        seq_join::seq_join,
        test_executor::run,
        test_fixture::{Runner, TestWorld},
    };

    #[derive(Step)]
    pub(crate) enum Step {
        TestRight,
        TestLeft,
    }

    #[test]
    fn polynomial_compression_test() {
        let r_f = 2usize;
        let mut rng = thread_rng();
        let e_p = (0..r_f)
            .map(|i| Fp25519::try_from(i as u128).unwrap())
            .collect::<Vec<Fp25519>>();
        // random mask
        let mask = (&rng.gen::<Fp25519>(), &rng.gen::<Fp25519>());
        // random points (i.e. verifier challenge points), need `1 + log 8`, `1` is needed for mask
        let mut r = vec![Fp25519::ZERO; 4];
        r.iter_mut().for_each(|x| *x = rng.gen());
        // random shares of u
        let u = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        u.0.iter_mut().for_each(|x| *x = rng.gen());
        u.0.iter_mut().for_each(|x| *x = rng.gen());

        // u in the clear
        let mut u_in_the_clear =
            u.0.iter()
                .zip(u.1.iter())
                .map(|(u0, u1)| *u0 + *u1)
                .collect::<Vec<Fp25519>>();

        // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
        let mut denominators = vec![Fp25519::ONE; r_f];
        compute_lagrange_denominator(&e_p[0..r_f], &mut denominators);

        // compute reconstruct on shares
        let (p0, q0) =
            polynomial_compression(&mut u.0.clone(), u.0, mask, r_f, &e_p, &denominators, &r);
        let (p1, q1) = polynomial_compression(
            &mut u.1.clone(),
            u.1,
            (&Fp25519::ZERO, &Fp25519::ZERO),
            r_f,
            &e_p,
            &denominators,
            &r,
        );

        // compute it on the clear, left and right is supposed to be the same
        let (p, q) = polynomial_compression(
            &mut u_in_the_clear.clone(),
            &mut u_in_the_clear,
            mask,
            r_f,
            &e_p,
            &denominators,
            &r,
        );

        assert_eq!((mask, p0 + p1, q0 + q1), (mask, p, q));
    }

    /// helper function for test
    async fn helper_fn_generate_proof<C>(
        ctx: C,
        r_f: usize,
        u_and_v: &[AdditiveShare<Fp25519>],
    ) -> (Fp25519, (NIDZKP<Fp25519>, NIDZKP<Fp25519>))
    where
        C: Context,
    {
        // collect vectors
        let mut u = u_and_v
            .iter()
            .map(ReplicatedSecretSharing::left)
            .collect::<Vec<_>>();
        let mut v = u_and_v
            .iter()
            .map(ReplicatedSecretSharing::right)
            .collect::<Vec<_>>();

        // compute out statement for proof
        let out = u_and_v.iter().fold(Fp25519::ZERO, |acc, u_and_v| {
            acc + u_and_v.left() * u_and_v.right()
        });

        (out, generate_proof(ctx, &mut u, &mut v, r_f).await.unwrap())
    }

    /// helper function for test, allows to send proofs and secret shares
    async fn helper_fn_send_and_receive_shares<C>(
        ctx: C,
        out: &Fp25519,
        u_and_v: &[AdditiveShare<Fp25519>],
        u_and_v_left: &[AdditiveShare<Fp25519>],
    ) -> (
        Fp25519,
        Vec<Fp25519>,
        Vec<Fp25519>,
        Vec<Fp25519>,
        Vec<Fp25519>,
    )
    where
        C: Context,
    {
        // use random shares
        let u_share_left = u_and_v_left
            .iter()
            .map(ReplicatedSecretSharing::left)
            .collect::<Vec<_>>();
        let v_share_left = u_and_v_left
            .iter()
            .map(ReplicatedSecretSharing::right)
            .collect::<Vec<_>>();

        // shares sent to the left:
        let u_share_right = u_and_v
            .iter()
            .zip(u_share_left.iter())
            .map(|(x, y)| x.left() - *y)
            .collect::<Vec<_>>();
        let v_share_right = u_and_v
            .iter()
            .zip(v_share_left.iter())
            .map(|(x, y)| x.right() - *y)
            .collect::<Vec<_>>();

        assert_eq!(u_and_v[0].left(), u_share_left[0] + u_share_right[0]);
        assert_eq!(u_and_v[0].right(), v_share_left[0] + v_share_right[0]);

        let length = u_share_left.len();

        // record size
        let l_left = 1 + 2 * length;
        let l_right = 2 * length;

        // let mut proof_right_vec = vec![Fp25519::ZERO;proof_length];
        let mut out_right = Fp25519::ZERO;
        let mut u_left = vec![Fp25519::ZERO; length];
        let mut u_right = vec![Fp25519::ZERO; length];
        let mut v_left = vec![Fp25519::ZERO; length];
        let mut v_right = vec![Fp25519::ZERO; length];

        // set up context
        let ctx_left = ctx.narrow(&Step::TestLeft).set_total_records(l_left);
        let ctx_right = ctx.narrow(&Step::TestRight).set_total_records(l_right);
        // set up channels
        let send_channel_left: &SendingEnd<Fp25519> =
            &ctx_left.send_channel(ctx.role().peer(Direction::Left));
        let send_channel_right: &SendingEnd<Fp25519> =
            &ctx_right.send_channel(ctx.role().peer(Direction::Right));
        let receive_channel_right: &ReceivingEnd<Fp25519> =
            &ctx_left.recv_channel(ctx.role().peer(Direction::Right));
        let receive_channel_left: &ReceivingEnd<Fp25519> =
            &ctx_right.recv_channel(ctx.role().peer(Direction::Left));

        // send to left, receive on the right
        seq_join(
            ctx_left.active_work(),
            stream::iter(
                std::iter::once(out)
                    .chain(u_share_right.iter())
                    .chain(v_share_right.iter())
                    .enumerate()
                    .map(|(i, x)| async move {
                        send_channel_left.send(RecordId::from(i), *x).await.unwrap();
                        receive_channel_right
                            .receive(RecordId::from(i))
                            .await
                            .unwrap()
                    }),
            ),
        )
        .collect::<Vec<_>>()
        .await
        .iter()
        .zip(
            std::iter::once(&mut out_right)
                .chain(u_right.iter_mut())
                .chain(v_right.iter_mut()),
        )
        .for_each(|(x, y)| *y = *x);

        // send to right, receive on the left
        seq_join(
            ctx_right.active_work(),
            stream::iter(
                u_share_left
                    .iter()
                    .chain(v_share_left.iter())
                    .enumerate()
                    .map(|(i, x)| async move {
                        send_channel_right
                            .send(RecordId::from(i), *x)
                            .await
                            .unwrap();
                        receive_channel_left
                            .receive(RecordId::from(i))
                            .await
                            .unwrap()
                    }),
            ),
        )
        .collect::<Vec<_>>()
        .await
        .iter()
        .zip(u_left.iter_mut().chain(v_left.iter_mut()))
        .for_each(|(x, y)| *y = *x);

        // output
        (out_right, u_left, u_right, v_left, v_right)
    }

    #[test]
    fn proof_verification_test() {
        run(|| async move {
            let world = TestWorld::default();

            let mut rng = thread_rng();
            let mut u_and_v = vec![Fp25519::ZERO; 3];
            u_and_v.iter_mut().for_each(|x| *x = rng.gen());
            let mut u_and_v_left = vec![Fp25519::ZERO; 3];
            u_and_v_left.iter_mut().for_each(|x| *x = rng.gen());

            let _ = world
                .semi_honest(
                    (u_and_v.into_iter(), u_and_v_left.into_iter()),
                    |ctx, (input, input_left)| async move {
                        // compute proof
                        let (out, proof) =
                            helper_fn_generate_proof(ctx.clone(), 2usize, &input).await;
                        // send proofs, generate shares
                        let (out_right, mut u_left, mut u_right, mut v_left, mut v_right) =
                            helper_fn_send_and_receive_shares(
                                ctx.clone(),
                                &out,
                                &input,
                                &input_left,
                            )
                            .await;

                        // verify proof
                        verify_proof(
                            ctx,
                            &proof.0,
                            &proof.1,
                            &out_right,
                            (&mut u_left, &mut u_right),
                            (&mut v_left, &mut v_right),
                        )
                        .await
                        .unwrap();
                    },
                )
                .await;
        });
    }
}
