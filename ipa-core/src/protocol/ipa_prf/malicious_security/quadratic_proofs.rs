use futures_util::future;
use generic_array::{ArrayLength, GenericArray};
use hkdf::Hkdf;
use sha2::Sha256;
use typenum::Unsigned;

use crate::{
    ff::{Error, Field, Invert, Serializable},
    protocol::{
        context::Context,
        ipa_prf::malicious_security::lagrange::{
            compute_lagrange_base, compute_lagrange_denominator, generate_evaluation_points,
            lagrange_evaluation, lagrange_evaluation_precomputed,
        },
        prss::SharedRandomness,
        RecordId,
    },
    secret_sharing::replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
};

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the vector length of `g_left` determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used Vec instead of GenArray)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    proofs: Vec<Vec<F>>,
}

/// generates recursive proof for sum_i u_i*v_i = out over field F
/// `r_f`, i.e. recursion factor, determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
/// this proof is sent to the party on the left
/// it is therefore the "right proof" of the party on the left
/// the left part of the proof is implicitly generated by the party on the right using left prss during verification
pub fn generate_proof<F>(
    //ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    r_f: usize,
) -> NIDZKP<F>
where
    F: Field + Invert,
    //C: Context,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - r_f.leading_zeros() + 1);

    let mut output = NIDZKP {
        proofs: Vec::with_capacity(1),
    };

    // record counter
    let mut counter = 0usize;

    // precomputation for Lagrange
    let mut evaluation_points = vec![F::ZERO; 2 * r_f];
    generate_evaluation_points(&mut evaluation_points);
    // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
    let mut denominators = vec![F::ONE; r_f];
    compute_lagrange_denominator(&evaluation_points[0..r_f], &mut denominators);
    let mut base_canonical = vec![vec![F::ONE; r_f]; r_f];
    compute_lagrange_base(
        &evaluation_points[r_f..2 * r_f],
        &evaluation_points[0..r_f],
        &denominators,
        &mut base_canonical,
    );

    // iterate over recursions
    while u.len() >= r_f {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = u.len() % r_f;
        if coset != 0 {
            u.extend(std::iter::repeat(F::ZERO).take(coset));
            v.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = u.len() / r_f;

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * r_f];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(r_f)
            .zip(v.chunks(r_f))
            .for_each(|(u, v)| compute_summand_of_g(u, v, r_f, &base_canonical, &mut g));

        // compute secret share g_left (i.e. part of the proof recovered by right party) using prss_right
        let mut g_left = vec![F::ZERO; g.len()];
        g_left.iter_mut().for_each(|g| {
            // get prss
            // todo replace `F::ONE` with actual prss value

            // compute `g_left`
            *g = F::ONE;
        });

        // compute secret share `g_right` by computing `g_right=g-g_left`
        // since `g` already contains `g`, we just need to subtract `g_left`
        g.iter_mut()
            .zip(g_left.iter())
            .for_each(|(g_right, g_left)| *g_right -= *g_left);

        // compute random point `r` via `Fiat-Shamir` hash
        // generate `r` as `hash(g_right) + hash(g_right)`
        let mut r = F::ZERO;
        compute_r_prover(&g, &g_left, &mut r);

        // add `g_right` to proof
        output.proofs.push(g);

        // precompute Lagrange base for `r`
        let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
        compute_lagrange_base(
            &std::slice::from_ref(&r),
            &evaluation_points[0..r_f],
            &denominators,
            &mut base_r,
        );

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; s];
        u_new.iter_mut().zip(u.chunks(r_f)).for_each(|(u, chunk)| {
            lagrange_evaluation_precomputed(&chunk, &base_r, std::slice::from_mut(u));
        });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; s];
        v_new.iter_mut().zip(v.chunks(r_f)).for_each(|(v, chunk)| {
            lagrange_evaluation_precomputed(&chunk, &base_r, std::slice::from_mut(v));
        });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(s);
        v.truncate(s);
    }

    // define last g
    let mut final_g = vec![F::ZERO; 2 * r_f];

    // generate final `evaluation_points`
    // generate mask p[0] from prss_right and append to u
    // generate mask q[0] from prss_right and append to v
    // todo
    let (final_u, final_v) = {
        let mut vec_u = Vec::<F>::with_capacity(r_f);
        let mut vec_v = Vec::<F>::with_capacity(r_f);
        // add prss masks
        // todo
        vec_u.push(F::ONE);
        vec_v.push(F::ONE);
        // copy rest
        vec_u.extend(&*u);
        vec_v.extend(&*v);
        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = vec_u.len() % r_f;
        if coset != 0 {
            vec_u.extend(std::iter::repeat(F::ZERO).take(coset));
            vec_v.extend(std::iter::repeat(F::ZERO).take(coset));
        }
        (vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(
        &final_u,
        &final_v,
        final_u.len(),
        &base_canonical,
        &mut final_g,
    );

    // generate last secret share
    let mut g_left = vec![F::ZERO; final_g.len()];
    g_left.iter_mut().for_each(|g| {
        // get prss
        // todo replace `F::ONE` with actual prss value

        // compute `g_left`
        *g = F::ONE;
    });

    // add secret share of g to the proofs
    // todo
    final_g
        .iter_mut()
        .zip(g_left.iter())
        .for_each(|(g_right, g_left)| *g_right -= *g_left);

    output.proofs.push(final_g);

    return output;
}

/// verify proof
/// needs interaction to compute the hashes, i.e. random points
// need to change it to async once prss is incorporated
// todo
pub fn verify_proof<F>(
    //ctx: C,
    proof_right: &NIDZKP<F>,
    out: &F,
    share_of_u: (&mut Vec<F>, &mut Vec<F>),
    share_of_v: (&mut Vec<F>, &mut Vec<F>),
) -> Result<bool, Error>
where
    //C: Context,
    F: Field + Invert,
{
    // setup output
    let mut output = true;

    // check that there is at least one recursion
    debug_assert!(proof_right.proofs.len() > 1);
    // compute recursion factor
    let r_f = proof_right.proofs[0].len() >> 1;

    // evaluation points for Lagrange
    let mut e_p = vec![F::ZERO; 2 * r_f];
    generate_evaluation_points(&mut e_p);

    // compute left part of the proof
    // todo
    let proof_left = &mut NIDZKP {
        proofs: Vec::with_capacity(proof_right.proofs.len()),
    };
    proof_right
        .proofs
        .iter()
        // add prss value to proof
        // todo
        .for_each(|x| proof_left.proofs.push(vec![F::ONE; x.len()]));

    // declarations
    let mut r_right = vec![F::ZERO; proof_right.proofs.len()];
    let mut r_left = vec![F::ZERO; proof_left.proofs.len()];
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len() + 1];
    let mut g_r_left = vec![F::ONE; proof_left.proofs.len() + 1];

    // dummy fs:
    r_left
        .iter_mut()
        .zip(r_right.iter_mut())
        .zip(proof_left.proofs.iter().zip(proof_right.proofs.iter()))
        .for_each(|((r_left, r_right), (proof_left, proof_right))| {
            compute_r_prover(&proof_left, &proof_right, r_left);
            *r_right = *r_left;
        });

    for (r, g_r, proof, g_r_0) in [
        (&r_right, &mut g_r_right, proof_right, out),
        (&r_left, &mut g_r_left, proof_left, &F::ZERO),
    ] {
        // compute r's using fiat+shamir
        // todo replace dummy fs above with `compute_r_verifier`

        // last `r` is not allowed to be in `evaluation_points[0..recursion_factor]`
        // therefore, we use `compute_final_r`
        //
        // todo

        // then compute g_r using lagrange_evaluation
        compute_g_r(proof, g_r_0, r, r_f, &e_p, g_r);

        // compute `g_r = g_r-sum g(x)`
        compute_sums_gr_gm(proof, g_r);
    }

    // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
    let mut denominators = vec![F::ONE; r_f];
    compute_lagrange_denominator(&e_p[0..r_f], &mut denominators);
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    // add masks to left, i.e. ".0",
    // compute both, p,q at once since Langrage precomputation is base on `r` which is identical
    let (p_left, q_left) = polynomial_compression(
        (share_of_u.0, share_of_v.0),
        &F::ONE,
        r_f,
        &e_p[0..r_f],
        &denominators,
        &r_left,
    );
    let (p_right, q_right) = polynomial_compression(
        (share_of_u.1, share_of_v.1),
        &F::ZERO,
        r_f,
        &e_p[0..r_f],
        &denominators,
        &r_right,
    );

    // todo consolidate zero checks

    // zero test
    // check that all sums `g_r == 0`
    // todo
    // dummy debug zero test:
    g_r_right[0..g_r_right.len() - 1]
        .iter()
        .zip(g_r_left[0..g_r_left.len() - 1].iter())
        .enumerate()
        .for_each(|(i, (x_right, x_left))| {
            debug_assert_eq!(
                (i, x_right, x_left, *x_right + *x_left),
                (i, x_right, x_left, F::ZERO)
            );
            output &= *x_right + *x_left == F::ZERO
        });

    debug_assert!(output);
    // final check:

    // reveal q(r), p(r) and g(r) and verify p(r)*g(r)=G(r)
    // todo
    // dummy debug verify:
    debug_assert_eq!(
        (p_left + p_right) * (q_left + q_right),
        g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1]
    );
    output &= (p_left + p_right) * (q_left + q_right)
        == g_r_right[g_r_right.len() - 1] + g_r_left[g_r_left.len() - 1];

    Ok(output)
}

/// replaces `g_previous(r)` with `g_previous(r)-sum_(x in evaluation_points) g_current(x)`
/// We only include `g(x)` for evaluation points `x` that correspond to an actual `v`, `u` values
/// These `g(x)` are only the first half of points used to represent `g`,
/// the second half of points guarantee that `g` has degree `2*recursion_factor-1`
/// the sums are later verified to be zero which is one of the two equations checked by the verifiers
fn compute_sums_gr_gm<F>(proof: &NIDZKP<F>, g_r: &mut [F]) -> ()
where
    F: Field,
{
    // compute sum of proofs
    // only sum the first `recursion_factor = proof.len()/2` many points,
    // the other points are just to ensure the degree of g is `2*recursion_factor-1`
    g_r.iter_mut()
        .zip(proof.proofs.iter())
        .for_each(|(x, proof)| {
            *x -= proof[0..proof.len() >> 1]
                .iter()
                .fold(F::ZERO, |acc, x| acc + *x)
        });

    // remove the mask from the sum for the last proof,
    // i.e. values at index 0 (corresponding to `u_0`, `v_0`)
    g_r[proof.proofs.len() - 1] += proof.proofs[proof.proofs.len() - 1][0];
}

fn compute_g_r<F>(
    proof: &NIDZKP<F>,
    out: &F,
    random_points: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g_r: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(proof.proofs.len() + 1, g_r.len());
    debug_assert_eq!(evaluation_points.len(), 2 * recursion_factor);
    debug_assert_eq!(random_points.len(), proof.proofs.len());

    let mut iter_right = g_r.iter_mut();
    *iter_right.next().unwrap() = out.clone();
    iter_right
        .zip(proof.proofs.iter())
        .zip(random_points.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points[0..g.len()],
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });
}

/// the `polynomial_compression` function
/// given a vector `share`,
/// recursively shrink the vector
/// by treating chunks of the vector as degree `recursion_factor -1` polynomials
/// and evaluate the polynomial on the `random_points`
/// until each `random_point` has been used and `share` collapsed to a single element
/// the polynomials are represented by points on the polynomial at the `evaluation_points`
/// mask is the `0` point during the last recursion
fn polynomial_compression<F>(
    share: (&mut Vec<F>, &mut Vec<F>),
    mask: &F,
    r_f: usize,
    e_p: &[F],
    denominators: &[F],
    r_p: &[F],
) -> (F, F)
where
    F: Field + Invert,
{
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - r_f.leading_zeros() + 1);
    debug_assert_eq!(e_p.len(), r_f);
    debug_assert_eq!(e_p.len(), denominators.len());
    debug_assert_eq!(share.0.len(), share.1.len());

    // iterate over recursions
    for r in r_p.iter().take(r_p.len() - 1) {
        // check whether there are too many random points,
        // which leads to unnecessary compression
        debug_assert!(share.0.len() >= r_f);

        // fill u and v with zeros such that it is a multiple of the recursion factor
        let coset = share.0.len() % r_f;
        if coset != 0 {
            share.0.extend(std::iter::repeat(F::ZERO).take(coset));
            share.1.extend(std::iter::repeat(F::ZERO).take(coset));
        }

        // amount of polynomials in `share`
        let s = share.0.len() / r_f;

        let mut share_new_0 = vec![F::ONE; s];
        let mut share_new_1 = vec![F::ONE; s];

        // precompute Lagrange base for `r`
        let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
        compute_lagrange_base(
            std::slice::from_ref(r),
            &e_p[0..r_f],
            &denominators,
            &mut base_r,
        );

        // `share` is split into chunks of size `recursion_factor`
        // to represent the polynomials
        // which are represented by `recursion_factor` many values in `share`
        // we then Lagrange evaluate it on the next `random_point` to compute new elements in `share`
        share_new_0
            .iter_mut()
            .zip(share.0.chunks(r_f))
            .for_each(|(u, chunk)| {
                lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(u));
            });
        share_new_1
            .iter_mut()
            .zip(share.1.chunks(r_f))
            .for_each(|(u, chunk)| {
                lagrange_evaluation_precomputed(chunk, &base_r, std::slice::from_mut(u));
            });
        // reassign new `share` for next iteration
        *share.0 = share_new_0;
        *share.1 = share_new_1;
        share.0.truncate(s);
        share.1.truncate(s);
    }

    debug_assert!(share.0.len() < r_f);

    // final shares, compute output
    let mut output_0 = F::ONE;
    let mut output_1 = F::ONE;

    let (final_share_0, final_share_1) = {
        let mut vec_0 = Vec::<F>::with_capacity(r_f);
        let mut vec_1 = Vec::<F>::with_capacity(r_f);
        // add prss mask
        vec_0.push(*mask);
        vec_1.push(*mask);
        // copy rest
        vec_0.extend(&*share.0);
        vec_1.extend(&*share.1);
        // fill u and v with zeros such that it is a multiple of the recursion factor
        vec_0.extend(std::iter::repeat(F::ZERO).take(vec_0.len() % r_f));
        vec_1.extend(std::iter::repeat(F::ZERO).take(vec_1.len() % r_f));
        (vec_0, vec_1)
    };

    // precompute Lagrange base for `r`
    let mut base_r = vec![vec![F::ONE; r_f]; 1usize];
    compute_lagrange_base(
        std::slice::from_ref(r_p.last().unwrap()),
        &e_p[0..r_f],
        &denominators,
        &mut base_r,
    );

    lagrange_evaluation_precomputed(&final_share_0, &base_r, std::slice::from_mut(&mut output_0));
    lagrange_evaluation_precomputed(&final_share_1, &base_r, std::slice::from_mut(&mut output_1));

    return (output_0, output_1);
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
fn compute_summand_of_g<F>(u: &[F], v: &[F], r_f: usize, base: &Vec<Vec<F>>, g: &mut [F]) -> ()
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(base.len(), u.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * r_f];

    // compute first recursion factor many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(r_f)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation_precomputed(u, &base, &mut summand_of_g[r_f..2 * r_f]);

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation_precomputed(v, &base, &mut summand_of_g[r_f..2 * r_f]);
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// computes random challenge `r` from `proof_right`
/// since the verifier has only access to `proof_right`,
/// further, he computes all `r` at once
/// he needs to receive `fiat_shamir(proof_left)` from the other verifier
/// `r` is computed has `fiat_shamir(proof_left)+fiat_shamir(proof_right)`
/// `compute_r_prover` takes as input `r` and adds the generated `r` to input `r`
// todo: make it async
fn compute_r_verifier<F>(proof_right: &NIDZKP<F>, r: &mut [F]) -> ()
where
    F: Field,
{
    debug_assert_eq!(proof_right.proofs.len(), r.len());
    r.iter_mut()
        .zip(proof_right.proofs.iter())
        .for_each(|(r, proof)| {
            fiat_shamir(proof, r);

            // send and receive r
            // todo replace `F::ZERO` with actual received `r`
            let r_received = F::ZERO;
            *r += r_received;
        });
}

/// computes random challenge `r` from `proof_part_left` and `proof_part_right`
/// since only the prover has access to both parts, only he can compute `r` this way
/// further, the prover computes `r` one by one rather than all `r` at once
/// `r` is computed has `fiat_shamir(proof_part_left)+fiat_shamir(proof_part_right)`
/// `compute_r_prover` takes as input `r` and adds the generated `r` to input `r`
fn compute_r_prover<F>(proof_left: &[F], proof_right: &[F], r: &mut F) -> ()
where
    F: Field,
{
    fiat_shamir(proof_left, r);
    fiat_shamir(proof_right, r);
}

/// the Fiat-Shamir core function
/// it takes a commitment, which is for `NIDZKP` the actual proof
/// and computes a vector of random points by hashing the individual proofs parts
/// this function only computes `r` for a single proof part
/// `fiat_shamir` takes an input `r` and adds the generated value to `r`
fn fiat_shamir<F>(proof: &[F], r: &mut F) -> ()
where
    F: Field,
{
    // serialize proof const SIZE: usize = <F as Serializable>::Size::USIZE;
    let mut ikm = Vec::<u8>::with_capacity(proof.len() * <F as Serializable>::Size::USIZE);
    proof.iter().for_each(|f| {
        let mut buf = vec![0u8; <F as Serializable>::Size::USIZE];
        f.serialize(GenericArray::from_mut_slice(&mut buf));
        ikm.extend(buf)
    });

    // compute `r` from `hash` of the proof
    let hk = Hkdf::<Sha256>::new(None, &ikm);
    // ideally we would generate `hash` as a `[u8;F::Size]` and `deserialize` it to generate `r`
    // however, deserialize might fail for some fields so we use `from_random_128` instead
    // therefore fields beyond `F::Size()>16` don't further reduce the cheating probability of the prover
    let mut hash = [0u8; 16];
    // hash length is a valid length so expand does not fail
    hk.expand(&[], &mut hash).unwrap();
    *r += F::from_random_u128(u128::from_le_bytes(hash));
}

#[cfg(all(test, unit_test))]
mod test {
    use futures::StreamExt;
    use futures_util::stream;
    use ipa_macros::Step;
    use rand::{thread_rng, Rng};

    use crate::{
        ff::ec_prime_field::Fp25519,
        helpers::{Direction, ReceivingEnd, SendingEnd},
        protocol::{
            context::Context,
            ipa_prf::malicious_security::{
                lagrange::compute_lagrange_denominator,
                quadratic_proofs::{generate_proof, polynomial_compression, verify_proof, NIDZKP},
            },
            RecordId,
        },
        secret_sharing::{
            replicated::{semi_honest::AdditiveShare, ReplicatedSecretSharing},
            SharedValue,
        },
        seq_join::seq_join,
        test_executor::run,
        test_fixture::{Runner, TestWorld},
    };

    #[test]
    fn polynomial_compression_test() {
        let recursion_factor = 2usize;
        let mut rng = thread_rng();
        let evaluation_points = (0..recursion_factor)
            .map(|i| Fp25519::try_from(i as u128).unwrap())
            .collect::<Vec<Fp25519>>();
        // random mask
        let mask = rng.gen::<Fp25519>();
        // random points (i.e. verifier challenge points), need `1 + log 8`, `1` is needed for mask
        let mut r = vec![Fp25519::ZERO; 4];
        r.iter_mut().for_each(|x| *x = rng.gen());
        // random shares of u
        let u = (&mut vec![Fp25519::ZERO; 8], &mut vec![Fp25519::ZERO; 8]);
        u.0.iter_mut().for_each(|x| *x = rng.gen());
        u.0.iter_mut().for_each(|x| *x = rng.gen());

        // u in the clear
        let mut u_in_the_clear =
            u.0.iter()
                .zip(u.1.iter())
                .map(|(u0, u1)| *u0 + *u1)
                .collect::<Vec<Fp25519>>();

        // precomputation for interpolation of `u`, `v`, i.e. degree `recursion_factor-1` polynomial
        let mut denominators = vec![Fp25519::ONE; recursion_factor];
        compute_lagrange_denominator(&evaluation_points[0..recursion_factor], &mut denominators);

        // compute reconstruct on shares
        let (p0, q0) = polynomial_compression(
            (&mut u.0.clone(), u.0),
            &mask,
            recursion_factor,
            &evaluation_points,
            &denominators,
            &r,
        );
        let (p1, q1) = polynomial_compression(
            (&mut u.1.clone(), u.1),
            &Fp25519::ZERO,
            recursion_factor,
            &evaluation_points,
            &denominators,
            &r,
        );

        // compute it on the clear, left and right is supposed to be the same
        let (p, q) = polynomial_compression(
            (&mut u_in_the_clear.clone(), &mut u_in_the_clear),
            &mask,
            recursion_factor,
            &evaluation_points,
            &denominators,
            &r,
        );

        assert_eq!((mask, p0 + p1, q0 + q1), (mask, p, q));
    }

    /// helper function for test
    fn helper_fn_generate_proof<C>(
        ctx: C,
        r_f: usize,
        u_and_v: &Vec<AdditiveShare<Fp25519>>,
    ) -> (Fp25519, NIDZKP<Fp25519>)
    where
        C: Context,
    {
        // collect vectors
        let mut u = u_and_v
            .iter()
            .map(|u_and_v| u_and_v.left())
            .collect::<Vec<_>>();
        let mut v = u_and_v
            .iter()
            .map(|u_and_v| u_and_v.right())
            .collect::<Vec<_>>();

        // compute out statement for proof
        let out = u_and_v.iter().fold(Fp25519::ZERO, |acc, u_and_v| {
            acc + u_and_v.left() * u_and_v.right()
        });

        let proof = generate_proof(&mut u, &mut v, r_f);

        (out, proof)
    }

    #[derive(Step)]
    pub(crate) enum Step {
        TestRight,
        TestLeft,
    }

    /// helper function for test, allows to send proofs and secret shares
    async fn helper_fn_send_and_receive_proofs_and_shares<C>(
        ctx: C,
        r_f: usize,
        out: &Fp25519,
        proof: &NIDZKP<Fp25519>,
        u_and_v: &Vec<AdditiveShare<Fp25519>>,
    ) -> (
        Fp25519,
        NIDZKP<Fp25519>,
        Vec<Fp25519>,
        Vec<Fp25519>,
        Vec<Fp25519>,
        Vec<Fp25519>,
    )
    where
        C: Context,
    {
        let length = u_and_v.len();
        let proof_length = proof.proofs.iter().fold(0usize, |acc, x| acc + x.len());

        // use identical shares to send to the right, todo use random shares
        let u_share_left = (0..length)
            .map(|x| Fp25519::try_from(0usize as u128).unwrap())
            .collect::<Vec<_>>();
        let v_share_left = (0..length)
            .map(|x| Fp25519::try_from(0usize as u128).unwrap())
            .collect::<Vec<_>>();
        // shares sent to the left:
        let u_share_right = u_and_v
            .iter()
            .zip(u_share_left.iter())
            .map(|(x, y)| x.left() + *y)
            .collect::<Vec<_>>();
        let v_share_right = u_and_v
            .iter()
            .zip(v_share_left.iter())
            .map(|(x, y)| x.right() + *y)
            .collect::<Vec<_>>();

        // record size
        let l_left = 1 + proof_length + 2 * length; //2*length;//;
        let l_right = 2 * length;

        // let mut proof_right_vec = vec![Fp25519::ZERO;proof_length];
        let mut out_right = Fp25519::ZERO;
        let mut proof_right = proof.clone();
        let mut u_left = vec![Fp25519::ZERO; length];
        let mut u_right = vec![Fp25519::ZERO; length];
        let mut v_left = vec![Fp25519::ZERO; length];
        let mut v_right = vec![Fp25519::ZERO; length];

        // set up context
        let ctx_left = ctx.narrow(&Step::TestLeft).set_total_records(l_left);
        let ctx_right = ctx.narrow(&Step::TestRight).set_total_records(l_right);
        // set up channels
        let send_channel_left: &SendingEnd<Fp25519> =
            &ctx_left.send_channel(ctx.role().peer(Direction::Left));
        let send_channel_right: &SendingEnd<Fp25519> =
            &ctx_right.send_channel(ctx.role().peer(Direction::Right));
        let receive_channel_right: &ReceivingEnd<Fp25519> =
            &ctx_left.recv_channel(ctx.role().peer(Direction::Right));
        let receive_channel_left: &ReceivingEnd<Fp25519> =
            &ctx_right.recv_channel(ctx.role().peer(Direction::Left));

        let mut tk = 0;
        for (i, x) in std::iter::once(out)
            .chain(proof.proofs.iter().flatten())
            .chain(u_share_right.iter())
            .chain(v_share_right.iter())
            .enumerate()
        {
            tk += 1;
        }
        assert_eq!(tk, 2 * length + proof_length + 1);

        // send to left, receive on the right
        seq_join(
            ctx_left.active_work(),
            stream::iter(
                std::iter::once(out)
                    .chain(proof.proofs.iter().flatten())
                    .chain(u_share_right.iter())
                    .chain(v_share_right.iter())
                    .enumerate()
                    .map(|(i, x)| async move {
                        send_channel_left.send(RecordId::from(i), *x).await.unwrap();
                        receive_channel_right
                            .receive(RecordId::from(i))
                            .await
                            .unwrap()
                    }),
            ),
        )
        .collect::<Vec<_>>()
        .await
        .iter()
        .zip(
            std::iter::once(&mut out_right)
                .chain(proof_right.proofs.iter_mut().flatten())
                .chain(u_right.iter_mut())
                .chain(v_right.iter_mut()),
        )
        .for_each(|(x, y)| *y = *x);

        // send to right, receive on the left
        seq_join(
            ctx_right.active_work(),
            stream::iter(
                u_share_left
                    .iter()
                    .chain(v_share_left.iter())
                    .enumerate()
                    .map(|(i, x)| async move {
                        send_channel_right
                            .send(RecordId::from(i), *x)
                            .await
                            .unwrap();
                        receive_channel_left
                            .receive(RecordId::from(i))
                            .await
                            .unwrap()
                    }),
            ),
        )
        .collect::<Vec<_>>()
        .await
        .iter()
        .zip(u_left.iter_mut().chain(v_left.iter_mut()))
        .for_each(|(x, y)| *y = *x);

        // output
        (out_right, proof_right, u_left, u_right, v_left, v_right)
    }

    #[test]
    fn proof_verification_test() {
        run(|| async move {
            let world = TestWorld::default();

            let mut rng = thread_rng();
            let mut u_and_v = vec![Fp25519::ZERO; 3];
            u_and_v.iter_mut().for_each(|x| *x = rng.gen());

            let result = world
                .semi_honest(u_and_v.into_iter(), |ctx, input| async move {
                    // compute proof
                    let (out, proof) = helper_fn_generate_proof(ctx.clone(), 2usize, &input);
                    let (out_right, proof_right, mut u_left, mut u_right, mut v_left, mut v_right) =
                        helper_fn_send_and_receive_proofs_and_shares(
                            ctx, 2usize, &out, &proof, &input,
                        )
                        .await;
                    // verify proof
                    verify_proof(
                        &proof_right,
                        &out_right,
                        (&mut u_left, &mut u_right),
                        (&mut v_left, &mut v_right),
                    )
                    .unwrap()
                })
                .await;

            assert!(result[0]);
            assert!(result[1]);
            assert!(result[2]);
        });
    }
}
