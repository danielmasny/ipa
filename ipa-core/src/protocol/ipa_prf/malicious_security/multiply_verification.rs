use bitvec::{prelude::Lsb0, vec::BitVec};
use futures_util::future;
use generic_array::{ArrayLength, GenericArray};
use ipa_macros::Step;
use rand::random;
use typenum::{U1, U7};

use crate::{
    ff::{ec_prime_field::Fp25519, Error, Field, Invert},
    helpers::{Direction, ReceivingEnd},
    protocol::{context::Context, prss::SharedRandomness, RecordId},
};

#[derive(Step)]
pub(crate) enum Step {
    SendProofs,
    SendProofLeft,
    SendProofRight,
    VerifyProofs,
    VerifyLeft,
    VerifyRight,
    GenerateG,
}

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the vector length of `g_left` determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used Vec instead of GenArray)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    proofs: Vec<Vec<F>>,
}

/// multiplication variables
/// consists of intermediate variables computed during an MPC multiply:
/// `z_l`, `z_r`, `x_l`, `x_r`, `y_l`, `y_r`, `alpha`
/// `z_r` has been generated by the party itself while party receives `z_l` from party on the right
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct multiplication_variables {
    z_l: BitVec<u8, Lsb0>,
    z_r: BitVec<u8, Lsb0>,
    x_l: BitVec<u8, Lsb0>,
    x_r: BitVec<u8, Lsb0>,
    y_l: BitVec<u8, Lsb0>,
    y_r: BitVec<u8, Lsb0>,
    alpha: BitVec<u8, Lsb0>,
}

/// Function that verifies honest behavior in mpc multiplications
/// outputs 0 when one helper party acts maliciously during multiplications
///
/// Takes as inputs a vector of an array of bits
/// each array is associated to one multiplication
/// where alpha_i is the PRSS randomness and z_(i-1) is the result of multiply sent by another party
pub async fn verify_multiply<C, F>(ctx: C, input: &multiplication_variables) -> Result<bool, Error>
where
    C: Context,
    F: Field,
{
    // convert inputs into `F`

    // call `generate_proof`

    // send & receive proofs
    // call `send_and_receive_proofs`

    // verify proofs
    // call `verify_proofs`

    Ok(true)
}

/// generates recursive proof for sum_i u_i*v_i = out over field F
/// `recursion_factor` determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
/// this proof is sent to the party on the left
/// it is therefore the "right proof" of the party on the left
/// the other part of the proof is implicitly generated by the party on the right using prss during verification
pub fn generate_proof<F>(
    //ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    recursion_factor: usize,
) -> NIDZKP<F>
where
    F: Field + Invert,
    //C: Context,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    let mut output = NIDZKP {
        proofs: Vec::with_capacity(1),
    };

    // record counter
    let mut counter = 0usize;

    // generate evaluation points `(F::0..F::(i)..)`
    let evaluation_points = (0..2 * recursion_factor + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // iterate over recursions
    while u.len() > recursion_factor {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        u.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));
        v.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = u.len() / recursion_factor;

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * recursion_factor];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(recursion_factor)
            .zip(v.chunks(recursion_factor))
            .for_each(|(u, v)| {
                compute_summand_of_g(
                    u,
                    v,
                    recursion_factor,
                    &evaluation_points[0..2 * recursion_factor],
                    &mut g,
                )
            });

        #[cfg(debug_assertions)]
        {
            let sum_uv = u
                .iter()
                .zip(v.iter())
                .fold(F::ZERO, |acc, (u, v)| acc + *u * *v);
            let sum_g = g[0..recursion_factor]
                .iter()
                .fold(F::ZERO, |acc, g| acc + *g);
            debug_assert_eq!(sum_uv, sum_g);
            // check interpolation
            if !output.proofs.is_empty() {
                let mut g_r_previous = F::ONE;
                lagrange_evaluation(
                    &evaluation_points[0..2 * recursion_factor],
                    &output.proofs.last().unwrap(),
                    std::slice::from_ref(&F::ZERO),
                    std::slice::from_mut(&mut g_r_previous),
                );
                debug_assert_eq!(g_r_previous, output.proofs.last().unwrap()[0]);
                debug_assert_eq!(g_r_previous, sum_uv);
            }
        }

        // secret share g using prss_right
        // todo

        // add secret share of g to the proofs
        output.proofs.push(g);

        // compute random point r via `Fiat-Shamir` hash
        // generate r as hash(g+prss_right) xor hash(prss_right)
        // r is not allowed to be in evaluation_points[0..recursion_factor]
        // todo
        let r = F::ZERO;

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; s];
        u_new
            .iter_mut()
            .zip(u.chunks(recursion_factor))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(u),
                )
            });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; s];
        v_new
            .iter_mut()
            .zip(v.chunks(recursion_factor))
            .for_each(|(v, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(v),
                )
            });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(s);
        v.truncate(s);
    }

    // define last g
    // since we add masks, the degree of g might be larger
    let mut final_g = vec![F::ZERO; 2 * u.len() + 2];

    // generate final `evaluation_points`
    // generate mask p[0] from prss_right and append to u
    // generate mask q[0] from prss_right and append to v
    // todo
    let (final_u, final_v) = {
        let mut vec_u = Vec::<F>::with_capacity(u.len() + 1);
        let mut vec_v = Vec::<F>::with_capacity(u.len() + 1);
        // add prss masks
        // todo
        vec_u.push(F::ONE);
        vec_v.push(F::ONE);
        // copy rest
        vec_u.extend(&*u);
        vec_v.extend(&*v);
        (vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(
        &final_u,
        &final_v,
        final_u.len(),
        &evaluation_points[..2 * u.len() + 2],
        &mut final_g,
    );

    // #[cfg(debug_assertions)]
    // {
    //     let sum_uv = final_u
    //         .iter()
    //         .zip(final_v.iter())
    //         .fold(F::ZERO, |acc, (u, v)| acc + *u * *v);
    //     let sum_g = final_g[0..final_u.len()]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     debug_assert_eq!(sum_uv, sum_g);
    //
    //     let sum_one = output.proofs[1][0..recursion_factor]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     assert_eq!(output.proofs[0][0],sum_one);
    //
    //     let length = output.proofs.last().unwrap().len()>>1;
    //     let mut g_r_previous = F::ONE;
    //     lagrange_evaluation(
    //         &evaluation_points[0..2*recursion_factor],
    //         &output.proofs[output.proofs.len()-2],
    //         std::slice::from_ref(&F::ZERO),
    //         std::slice::from_mut(&mut g_r_previous),
    //     );
    //     debug_assert_eq!(g_r_previous,output.proofs[output.proofs.len()-2][0]);
    //     let sum_last = output.proofs.last().unwrap()[0..length]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     assert_eq!(g_r_previous,sum_last);
    // }

    output.proofs.push(final_g);

    return output;
}

pub async fn send_and_receive_proof<C, F>(
    ctx: C,
    proofs: Vec<NIDZKP<F>>,
) -> Result<Vec<NIDZKP<F>>, Error>
where
    C: Context,
    F: Field,
{
    // let send_channel_right: SendingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     //placeholder:
    //     .set_total_records(1)
    //     .send_channel(ctx.role().peer(Direction::Right));

    // placeholder:
    // send_channel_left.send(RecordId::from(1), (hash_left,proof_left)).await?;

    // let receive_channel_left: ReceivingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     // placeholder:
    //     .set_total_records(1)
    //     .recv_channel(ctx.role().peer(Direction::Left));

    // let (hash_left,proof_left) =
    //     receive_channel_left.receive(RecordId::from(1)).await?;

    // placeholder:
    Ok(proofs)
}

/// verify proof
/// needs interaction to compute the hashes, i.e. random points
// need to change it to async once prss is incorporated
// todo
pub fn verify_proof<F>(
    //ctx: C,
    proof_right: &NIDZKP<F>,
    out_left: &F,
    out_right: &F,
    share_of_u: &mut Vec<F>,
    share_of_v: &mut Vec<F>,
) -> Result<bool, Error>
where
    //C: Context,
    F: Field + Invert,
{
    // setup output
    let mut output = true;

    // compute recursion factor
    let recursion_factor = proof_right.proofs[0].len() >> 1;

    // generate evaluation points `(F::0..F::(i)..)`
    let evaluation_points = (0..2 * recursion_factor + 2)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // compute left part of the proof
    // todo
    let proof_left = &mut NIDZKP {
        proofs: Vec::with_capacity(1),
    };
    proof_right
        .proofs
        .iter()
        .for_each(|x| proof_left.proofs.push(vec![F::ZERO; x.len()]));

    // first, compute r's using hashing and out
    // todo
    let r_right = vec![F::ZERO; proof_right.proofs.len()];
    let r_left = vec![F::ZERO; proof_left.proofs.len()];

    // then compute g_r using lagrange_evaluation
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len() + 1];
    compute_g_r(
        proof_right,
        out_right,
        &r_right,
        recursion_factor,
        &evaluation_points,
        &mut g_r_right,
    );

    // compute sum of proofs
    // only sum the first `recursion_factor = proof.len()/2` many points,
    // the other points are just to ensure the degree is `2*recursion_factor-1`
    g_r_right
        .iter_mut()
        .take(proof_right.proofs.len() - 1)
        .zip(proof_right.proofs.iter())
        .for_each(|(x, proof)| {
            *x -= proof[0..proof.len() >> 1]
                .iter()
                .fold(F::ZERO, |acc, x| acc + *x)
        });
    // length of last proof
    let length_last = proof_right.proofs[proof_right.proofs.len() - 1].len();
    // compute sum of last proof, dont sum up masks, i.e. values at index 0
    g_r_right[proof_right.proofs.len() - 1] -= proof_right.proofs[proof_right.proofs.len() - 1]
        [1..length_last >> 1]
        .iter()
        .fold(F::ZERO, |acc, x| acc + *x);

    // #[cfg(debug_assertions)]
    // {
    //     let length = proof_right.proofs.last().unwrap().len()>>1;
    //     let mut g_r_previous= F::ONE;
    //     lagrange_evaluation(
    //         &evaluation_points[0..2*recursion_factor],
    //         &proof_right.proofs[proof_right.proofs.len()-2],
    //         std::slice::from_ref(&F::ZERO),
    //         std::slice::from_mut(&mut g_r_previous),
    //     );
    //     debug_assert_eq!(g_r_previous,proof_right.proofs[proof_right.proofs.len()-2][0]);
    //     let sum_last = proof_right.proofs.last().unwrap()[0..length]
    //         .iter()
    //         .fold(F::ZERO, |acc, g| acc + *g);
    //     assert_eq!(g_r_previous,sum_last);
    // }

    // zero test
    // todo
    g_r_right[0..g_r_right.len() - 1]
        .iter()
        .enumerate()
        .for_each(|(i, x)| {
            debug_assert_eq!((i, *x), (i, F::ZERO));
            output &= *x == F::ZERO
        });

    debug_assert!(output);
    // final check:
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    let (p, q) = reconstruct_p_and_q(
        share_of_u,
        share_of_v,
        &F::ONE,
        &F::ONE,
        recursion_factor,
        &evaluation_points,
        &r_right,
    );
    // reveal q(r), p(r) and g(r) and check p(r)*g(r)=G(r)
    // todo
    debug_assert_eq!(p * q, g_r_right[g_r_right.len() - 1]);
    output &= p * q == g_r_right[g_r_right.len() - 1];

    Ok(output)
}

pub fn compute_g_r<F>(
    proof: &NIDZKP<F>,
    out: &F,
    random_points: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g_r: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(proof.proofs.len() + 1, g_r.len());
    debug_assert_eq!(evaluation_points.len(), 2 * recursion_factor + 2);
    debug_assert_eq!(random_points.len(), proof.proofs.len());

    let mut iter_right = g_r.iter_mut();
    *iter_right.next().unwrap() = out.clone();
    iter_right
        .zip(proof.proofs.iter())
        .zip(random_points.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points[0..g.len()],
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });
}

pub fn reconstruct_p_and_q<F>(
    share_of_u: &mut Vec<F>,
    share_of_v: &mut Vec<F>,
    mask_u: &F,
    mask_v: &F,
    recursion_factor: usize,
    evaluation_points: &[F],
    random_points: &[F],
) -> (F, F)
where
    F: Field + Invert,
{
    // check length
    debug_assert_eq!(share_of_u.len(), share_of_v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    // iterate over recursions
    for r in &random_points[0..random_points.len() - 1] {
        // fill u and v with zeros such that it is a multiple of the recursion factor
        share_of_u.extend(std::iter::repeat(F::ZERO).take(share_of_u.len() % recursion_factor));
        share_of_v.extend(std::iter::repeat(F::ZERO).take(share_of_u.len() % recursion_factor));

        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = share_of_u.len() / recursion_factor;

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut share_of_u_new = vec![F::ONE; s];
        share_of_u_new
            .iter_mut()
            .zip(share_of_u.chunks(recursion_factor))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(r),
                    std::slice::from_mut(u),
                )
            });
        // compute q(r) using v
        let mut share_of_v_new = vec![F::ONE; s];
        share_of_v_new
            .iter_mut()
            .zip(share_of_v.chunks(recursion_factor))
            .for_each(|(v, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(r),
                    std::slice::from_mut(v),
                )
            });
        // reassign u_new, v_new for next iteration
        *share_of_u = share_of_u_new;
        *share_of_v = share_of_v_new;
        share_of_u.truncate(s);
        share_of_v.truncate(s);
    }
    debug_assert_eq!(
        (share_of_u.len(), share_of_u.len() < recursion_factor + 1),
        (share_of_u.len(), true)
    );

    // final points
    let (final_share_of_u, final_share_of_v) = {
        let mut vec_u = Vec::<F>::with_capacity(share_of_u.len() + 1);
        let mut vec_v = Vec::<F>::with_capacity(share_of_u.len() + 1);
        // add prss masks
        // todo
        vec_u.push(*mask_u);
        vec_v.push(*mask_v);
        // copy rest
        vec_u.extend(&*share_of_u);
        vec_v.extend(&*share_of_v);
        (vec_u, vec_v)
    };

    let mut p = F::ONE;
    let mut q = F::ONE;
    lagrange_evaluation(
        &evaluation_points[0..final_share_of_u.len()],
        &final_share_of_u,
        std::slice::from_ref(&random_points[random_points.len() - 1]),
        std::slice::from_mut(&mut p),
    );
    lagrange_evaluation(
        &evaluation_points[0..final_share_of_u.len()],
        &final_share_of_v,
        std::slice::from_ref(&random_points[random_points.len() - 1]),
        std::slice::from_mut(&mut q),
    );

    return (p, q);
}

pub fn convert_variables_into_field<F>(variables: multiplication_variables) -> (Vec<F>, Vec<F>)
where
    F: Field,
{
    //placeholder:
    return (vec![F::ONE; 7], vec![F::ONE; 7]);
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
fn compute_summand_of_g<F>(
    u: &[F],
    v: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(evaluation_points.len(), 2usize * recursion_factor);
    debug_assert_eq!(evaluation_points.len(), g.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * recursion_factor];

    // compute first recursion factor many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(recursion_factor)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        u,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        v,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g[recursion_factor..2 * recursion_factor],
    );
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// lagrange evaluation
/// given points `(x_0,y_0),...,(x_n,y_0)` on a polynomial `p`
/// and points `p_0,...,p_m`
/// compute `result_0=result_0*p(p_0),...,result_m=result_m*p(p_m)`
/// It uses the lagrange method to compute the points `https://en.wikipedia.org/wiki/Lagrange_polynomial`
/// further, rather than outputting `p(p_k)`, we set `result_k=result_k*p(p_k)`
/// which fits better to how we use `p(p_k)`
pub fn lagrange_evaluation<F>(x: &[F], y: &[F], p: &[F], result: &mut [F]) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(x.len(), y.len());
    debug_assert_eq!(p.len(), result.len());
    #[cfg(debug_assertions)]
    {
        for i in 0..x.len() {
            for j in 0..x.len() {
                debug_assert_eq!((i, j, x[i] - x[j] != F::ZERO || j == i), (i, j, true))
            }
        }
    }

    // compute denominators:
    let mut denominator = vec![F::ONE; x.len()];
    for i in 0..x.len() {
        if i > 0 {
            for j in 0..i {
                denominator[i] *= x[i] - x[j];
            }
        }
        if i + 1 < x.len() {
            for j in i + 1..x.len() {
                denominator[i] *= x[i] - x[j];
            }
        }
        denominator[i] = denominator[i].invert();
    }

    for k in 0..p.len() {
        // evaluate polynomial on point p_k, i.e. compute `p(p_k)` use Lagrange formula
        let mut sum = F::ZERO;
        for i in 0..x.len() {
            let mut basis_polynomial = denominator[i] * y[i];
            if i > 0 {
                for j in 0..i {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            if i + 1 < x.len() {
                for j in i + 1..x.len() {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            sum += basis_polynomial;
        }
        // compute "result_k = result_k * p(p_k)"
        result[k] *= sum;
    }
}

#[cfg(all(test, unit_test))]

mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::{ec_prime_field::Fp25519, FieldType::Fp31},
        protocol::ipa_prf::malicious_security::multiply_verification::{
            generate_proof, lagrange_evaluation, verify_proof,
        },
        secret_sharing::SharedValue,
    };

    #[test]
    fn lagrange_evaluation_fp25519() {
        let mut rng = thread_rng();
        let evaluation_points_size = rng.gen::<usize>() % 100;
        let mut evaluation_points = vec![Fp25519::ONE; evaluation_points_size];
        evaluation_points
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        let mut y_values = vec![Fp25519::ONE; evaluation_points_size];
        y_values.iter_mut().for_each(|y| *y = rng.gen::<Fp25519>());
        let mut evaluated_y = vec![Fp25519::ONE; evaluation_points_size];
        lagrange_evaluation(
            &evaluation_points,
            &y_values,
            &evaluation_points,
            &mut evaluated_y,
        );

        // test evaluation at interpolation points
        assert_eq!(evaluated_y, y_values);

        // sample random polynomial in monomial form of degree `evaluation_points_size`
        let mut polynomial = vec![Fp25519::ONE; evaluation_points_size];
        polynomial
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        // add random point to evaluation points
        evaluation_points.push(rng.gen::<Fp25519>());

        // evaluate polynomial at evaluation_points
        let mut y_values = vec![Fp25519::ZERO; evaluation_points_size + 1];
        evaluation_points.iter().for_each(|x_value| {
            let mut base = Fp25519::ONE;
            polynomial.iter().for_each(|coefficient| {
                y_values.iter_mut().for_each(|y| *y = *coefficient * base);
                base *= *x_value
            })
        });

        // lagrange evaluate at random point
        evaluated_y[0] = Fp25519::ONE;
        lagrange_evaluation(
            &evaluation_points[0..evaluation_points_size],
            &y_values[0..evaluation_points_size],
            std::slice::from_ref(&evaluation_points[evaluation_points_size]),
            std::slice::from_mut(&mut evaluated_y[0]),
        );

        // check equality
        assert_eq!(y_values[evaluation_points_size], evaluated_y[0]);
    }

    #[test]
    fn debug_test() {
        let recursion_factor = 2usize;
        let mut rng = thread_rng();
        let mut u = vec![Fp25519::ZERO; 8];
        let mut v = vec![Fp25519::ZERO; 8];
        u.iter_mut().for_each(|x| *x = rng.gen());
        v.iter_mut().for_each(|x| *x = rng.gen());
        let out = u
            .iter()
            .zip(v.iter())
            .fold(Fp25519::ZERO, |acc, (u, v)| acc + (*u * *v));
        let proof = generate_proof(&mut u.clone(), &mut v.clone(), recursion_factor);
        let sum = proof.proofs.clone()[0][0..recursion_factor]
            .iter()
            .fold(Fp25519::ZERO, |acc, g| acc + *g);
        assert_eq!(out, sum);
        let mut g_r_one = Fp25519::ONE;
        let evaluation_points = (0..2 * recursion_factor + 2)
            .map(|i| Fp25519::try_from(i as u128).unwrap())
            .collect::<Vec<Fp25519>>();
        lagrange_evaluation(
            &evaluation_points[0..2 * recursion_factor],
            &proof.proofs[0],
            std::slice::from_ref(&Fp25519::ZERO),
            std::slice::from_mut(&mut g_r_one),
        );
        assert_eq!(g_r_one, proof.proofs[0][0]);
        let sum_one = proof.proofs.clone()[1][0..recursion_factor]
            .iter()
            .fold(Fp25519::ZERO, |acc, g| acc + *g);
        assert_eq!(g_r_one, sum_one);

        // let length = proof.proofs.last().unwrap().len()>>1;
        // let mut g_r_previous = Fp25519::ONE;
        // lagrange_evaluation(
        //     &evaluation_points[0..2*recursion_factor],
        //     &proof.proofs[proof.proofs.len()-2],
        //     std::slice::from_ref(&Fp25519::ZERO),
        //     std::slice::from_mut(&mut g_r_previous),
        // );
        // debug_assert_eq!(g_r_previous,proof.proofs[proof.proofs.len()-2][0]);
        // let sum_last = proof.proofs.last().unwrap()[0..length]
        //     .iter()
        //     .fold(Fp25519::ZERO, |acc, g| acc + *g);
        // assert_eq!(g_r_previous,sum_last);

        assert!(verify_proof(&proof, &out, &out, &mut u, &mut v).unwrap());
    }
}
