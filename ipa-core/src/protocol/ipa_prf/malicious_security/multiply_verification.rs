use bitvec::{prelude::Lsb0, vec::BitVec};
use futures_util::future;
use generic_array::{ArrayLength, GenericArray};
use ipa_macros::Step;
use typenum::{U1, U7};

use crate::{
    ff::{ec_prime_field::Fp25519, Error, Field, Invert},
    helpers::{Direction, ReceivingEnd},
    protocol::{context::Context, prss::SharedRandomness, RecordId},
};

#[derive(Step)]
pub(crate) enum Step {
    SendProofs,
    SendProofLeft,
    SendProofRight,
    VerifyProofs,
    VerifyLeft,
    VerifyRight,
    GenerateG,
}

/// Non-Interactive Distributed Zero Knowledge Proof
/// a `NIDZKP` which is computed over multiple recursions , is a vector of `g` polynomials
/// the length is the amount of proof recursions
/// `g` is secret shared using PRSS: left share is stored in struct, right share is generated via PRSS
/// the vector length of `g_left` determines the degree of the polynomial
/// for a low communication rate, i.e. `log (amount of multiplications)`,
/// the length needs to be constant in the amount of multiplications
/// length might be different across recursions (therefore used Vec instead of GenArray)
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NIDZKP<F>
where
    F: Field,
{
    proofs: Vec<Vec<F>>,
}

/// multiplication variables
/// consists of intermediate variables computed during an MPC multiply:
/// `z_l`, `z_r`, `x_l`, `x_r`, `y_l`, `y_r`, `alpha`
/// `z_r` has been generated by the party itself while party receives `z_l` from party on the right
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct multiplication_variables {
    z_l: BitVec<u8, Lsb0>,
    z_r: BitVec<u8, Lsb0>,
    x_l: BitVec<u8, Lsb0>,
    x_r: BitVec<u8, Lsb0>,
    y_l: BitVec<u8, Lsb0>,
    y_r: BitVec<u8, Lsb0>,
    alpha: BitVec<u8, Lsb0>,
}

/// Function that verifies honest behavior in mpc multiplications
/// outputs 0 when one helper party acts maliciously during multiplications
///
/// Takes as inputs a vector of an array of bits
/// each array is associated to one multiplication
/// where alpha_i is the PRSS randomness and z_(i-1) is the result of multiply sent by another party
pub async fn verify_multiply<C, F>(ctx: C, input: &multiplication_variables) -> Result<bool, Error>
where
    C: Context,
    F: Field,
{
    // convert inputs into `F`

    // call `generate_proof`

    // send & receive proofs
    // call `send_and_receive_proofs`

    // verify proofs
    // call `verify_proofs`

    Ok(true)
}

/// generates recursive proof for sum_i u_i*v_i = out over field F
/// `recursion_factor` determines how much the inputs are compressed during each recursion
/// it is also the degree of polynomials p and q
/// this proof is sent to the party on the left
/// it is therefore the "right proof" of the party on the left
/// the other part of the proof is implicitly generated by the party on the right using prss during verification
pub fn generate_proof<C, F>(
    ctx: C,
    u: &mut Vec<F>,
    v: &mut Vec<F>,
    recursion_factor: usize,
) -> NIDZKP<F>
where
    F: Field + Invert,
    C: Context,
{
    // check length
    debug_assert_eq!(u.len(), v.len());
    // check that field is large enough to hold evaluation points
    debug_assert!(F::BITS > usize::BITS - recursion_factor.leading_zeros() + 1);

    let mut output = NIDZKP {
        proofs: Vec::with_capacity(1),
    };

    // record counter
    let mut counter = 0usize;

    // generate evaluation points as multiples of `F::ONE`
    let evaluation_points = (0..recursion_factor)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // iterate over recursions
    while u.len() > recursion_factor {
        // amount of polynomials `p`, `q`, i.e. amount of `summand_of_g`
        let s = u.len() / recursion_factor;

        // fill u and v with zeros such that it is a multiple of the recursion factor
        u.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));
        v.extend(std::iter::repeat(F::ZERO).take(u.len() % recursion_factor));

        // define `g` which is represented by `2*recursion_factor` many points.
        let mut g = vec![F::ZERO; 2 * recursion_factor];

        // compute `g` which is the sum of `summand_of_g`
        u.chunks(recursion_factor)
            .zip(v.chunks(recursion_factor))
            .for_each(|(u, v)| {
                compute_summand_of_g(u, v, recursion_factor, &evaluation_points, &mut g)
            });
        // secret share g using prss_right
        // todo

        // add secret share of g to the proofs
        output.proofs.push(g);

        // compute random point r via `Fiat-Shamir` hash
        // generate r as hash(g+prss_right) xor hash(prss_right)
        // r is not allowed to be in evaluation_points[0..recursion_factor]
        // todo
        let r = F::ZERO;

        // evaluate p, q to get new u, v
        // u, v are split into chunks to represent p(evaluation_points), q(evaluation_points)
        // lagrange_evaluation is used to compute p(r), q(r) from p(evaluation_points), q(evaluation_points)
        // compute p(r) using u
        let mut u_new = vec![F::ONE; s];
        u_new
            .iter_mut()
            .zip(u.chunks(recursion_factor))
            .for_each(|(u, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(u),
                )
            });
        // compute q(r) using v
        let mut v_new = vec![F::ONE; s];
        v_new
            .iter_mut()
            .zip(v.chunks(recursion_factor))
            .for_each(|(v, chunk)| {
                lagrange_evaluation(
                    &evaluation_points[0..recursion_factor],
                    chunk,
                    std::slice::from_ref(&r),
                    std::slice::from_mut(v),
                )
            });
        // reassign u_new, v_new for next iteration
        *u = u_new;
        *v = v_new;
        u.truncate(s);
        v.truncate(s);
    }

    // define last g
    let mut g = vec![F::ZERO; 2 * u.len()];

    // generate final `evaluation_points`
    // generate mask p[0] from prss_right and append to u
    // generate mask q[0] from prss_right and append to v
    // todo
    let (final_evaluation_points, final_u, final_v) = {
        let mut vec = Vec::<F>::with_capacity(2 * (u.len() + 1));
        let mut vec_u = Vec::<F>::with_capacity(u.len() + 1);
        let mut vec_v = Vec::<F>::with_capacity(u.len() + 1);
        vec = evaluation_points[0..2 * u.len() + 1].to_vec();
        vec_u = u.to_vec();
        vec_v = v.to_vec();
        vec.push(F::ZERO);
        // add prss masks
        // todo
        vec_u.push(F::ONE);
        vec_v.push(F::ONE);
        (vec, vec_u, vec_v)
    };

    // compute last g and add it to the proofs
    compute_summand_of_g(
        &final_u,
        &final_v,
        final_u.len(),
        &final_evaluation_points,
        &mut g,
    );
    output.proofs.push(g);

    return output;
}

pub async fn send_and_receive_proof<C, F>(
    ctx: C,
    proofs: Vec<NIDZKP<F>>,
) -> Result<Vec<NIDZKP<F>>, Error>
where
    C: Context,
    F: Field,
{
    // let send_channel_right: SendingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     //placeholder:
    //     .set_total_records(1)
    //     .send_channel(ctx.role().peer(Direction::Right));

    // placeholder:
    // send_channel_left.send(RecordId::from(1), (hash_left,proof_left)).await?;

    // let receive_channel_left: ReceivingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     // placeholder:
    //     .set_total_records(1)
    //     .recv_channel(ctx.role().peer(Direction::Left));

    // let (hash_left,proof_left) =
    //     receive_channel_left.receive(RecordId::from(1)).await?;

    // placeholder:
    Ok(proofs)
}

/// verify proof
/// needs interaction to compute the hashes, i.e. random points
// need to change it to async once prss is incorporated
// todo
pub fn verify_proof<C, F>(
    ctx: C,
    proof_right: &NIDZKP<F>,
    out_left: &F,
    out_right: &F,
    share_of_u: &mut Vec<F>,
    share_of_v: &mut Vec<F>,
) -> Result<bool, Error>
where
    C: Context,
    F: Field + Invert,
{
    // setup output
    let mut output = true;

    // compute recursion factor
    let recursion_factor = proof_right.proofs[0].len() >> 1;

    // generate evaluation points as multiples of `F::ONE`
    let evaluation_points = (0..recursion_factor)
        .map(|i| F::try_from(i as u128).unwrap())
        .collect::<Vec<F>>();

    // compute left part of the proof
    // todo
    let mut proof_left = NIDZKP {
        proofs: Vec::with_capacity(1),
    };
    proof_right
        .proofs
        .iter()
        .for_each(|x| proof_left.proofs.push(vec![F::ZERO; x.len()]));

    // first, compute r's using hashing and out
    // todo
    let r_right = vec![F::ZERO; proof_right.proofs.len()];
    let r_left = vec![F::ZERO; proof_left.proofs.len()];

    // then compute g_r using lagrange_evaluation
    let mut g_r_right = vec![F::ONE; proof_right.proofs.len()];
    let mut iter_right = g_r_right.iter_mut();
    *iter_right.next().unwrap() = *out_right;
    iter_right
        .zip(proof_right.proofs.iter())
        .zip(r_right.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points,
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });
    let mut g_r_left = vec![F::ONE; proof_right.proofs.len()];
    let mut iter_left = g_r_left.iter_mut();
    *iter_left.next().unwrap() = *out_left;
    iter_left
        .zip(proof_left.proofs.iter())
        .zip(r_left.iter())
        .for_each(|((g_r, g), r)| {
            lagrange_evaluation(
                &evaluation_points,
                &g,
                std::slice::from_ref(r),
                std::slice::from_mut(g_r),
            )
        });

    // compute sum of proofs
    g_r_right
        .iter_mut()
        .zip(proof_right.proofs.iter())
        .for_each(|(x, proof)| *x -= proof.iter().fold(F::ZERO, |acc, x| acc + *x));
    g_r_left
        .iter_mut()
        .zip(proof_left.proofs.iter())
        .for_each(|(x, proof)| *x -= proof.iter().fold(F::ZERO, |acc, x| acc + *x));

    // zero test
    // todo
    output ^= (F::ZERO
        == g_r_right.iter().fold(F::ZERO, |acc, x| acc + *x)
            + g_r_left.iter().fold(F::ZERO, |acc, x| acc + *x));

    // final check:
    // generate q(0), p(0) masks using PRSS,
    // compute polynomials p,q recursively
    // reveal q(r), p(r) and g(r) and check p(r)*g(r)=G(r)
    // todo

    Ok(true)
}

pub fn convert_variables_into_field<F>(variables: multiplication_variables) -> (Vec<F>, Vec<F>)
where
    F: Field,
{
    //placeholder:
    return (vec![F::ONE; 7], vec![F::ONE; 7]);
}

/// computes `summand_of_g = p*q` and adds it to `g`
/// polynomials `p` and `q` are represented by value `u`, `v`
/// which are the evaluations of `p,q` at `evaluation_points[0..recursion_factor]`
/// `g` is represented by its evaluation at `evaluation_points`
fn compute_summand_of_g<F>(
    u: &[F],
    v: &[F],
    recursion_factor: usize,
    evaluation_points: &[F],
    g: &mut [F],
) -> ()
where
    F: Field + Invert,
{
    // check lengths
    debug_assert_eq!(u.len(), v.len());
    debug_assert_eq!(evaluation_points.len(), 2usize * recursion_factor);
    debug_assert_eq!(evaluation_points.len(), g.len());

    // define summand of g, g = sum of summand_of_g
    // summand_of_g is represented by 2*recursion_factor many points.
    let mut summand_of_g = vec![F::ONE; 2 * recursion_factor];

    // compute first recursion point many points of summand_of_g
    summand_of_g
        .iter_mut()
        .take(recursion_factor)
        .enumerate()
        .for_each(|(i, x)| *x = u[i] * v[i]);

    // compute summand_of_g = 1*u for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        u,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g,
    );

    // compute summand_of_g = u*v for rest of points
    lagrange_evaluation(
        &evaluation_points[0..recursion_factor],
        v,
        &evaluation_points[recursion_factor..2 * recursion_factor],
        &mut summand_of_g,
    );
    // add summand_of_g to g
    g.iter_mut()
        .zip(summand_of_g.iter())
        .for_each(|(x, y)| *x += *y);
}

/// lagrange evaluation
/// given points `(x_0,y_0),...,(x_n,y_0)` on a polynomial `p`
/// and points `p_0,...,p_m`
/// compute `result_0=result_0*p(p_0),...,result_m=result_m*p(p_m)`
/// It uses the lagrange method to compute the points `https://en.wikipedia.org/wiki/Lagrange_polynomial`
/// further, rather than outputting `p(p_k)`, we set `result_k=result_k*p(p_k)`
/// which fits better to how we use `p(p_k)`
pub fn lagrange_evaluation<F>(x: &[F], y: &[F], p: &[F], result: &mut [F]) -> ()
where
    F: Field + Invert,
{
    debug_assert_eq!(x.len(), y.len());
    debug_assert_eq!(p.len(), result.len());

    // compute denominators:
    let mut denominator = vec![F::ONE; x.len()];
    for i in 0..x.len() {
        if i > 0 {
            for j in 0..i {
                denominator[i] *= (x[i] - x[j]);
            }
        }
        if i + 1 < x.len() {
            for j in i + 1..x.len() {
                denominator[i] *= x[i] - x[j];
            }
        }
        denominator[i] = denominator[i].invert();
    }

    for k in 0..p.len() {
        // evaluate polynomial on point p_k, i.e. compute `p(p_k)` use Lagrange formula
        let mut sum = F::ZERO;
        for i in 0..x.len() {
            let mut basis_polynomial = denominator[i] * y[i];
            if i > 0 {
                for j in 0..i {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            if i + 1 < x.len() {
                for j in i + 1..x.len() {
                    basis_polynomial *= p[k] - x[j];
                }
            }
            sum += basis_polynomial;
        }
        // compute "result_k = result_k * p(p_k)"
        result[k] *= sum;
    }
}

#[cfg(all(test, unit_test))]

mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::ec_prime_field::Fp25519,
        protocol::ipa_prf::malicious_security::multiply_verification::lagrange_evaluation,
        secret_sharing::SharedValue,
    };

    #[test]
    fn lagrange_evaluation_fp25519() {
        let mut rng = thread_rng();
        let evaluation_points_size = rng.gen::<usize>() % 100;
        let mut evaluation_points = vec![Fp25519::ONE; evaluation_points_size];
        evaluation_points
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        let mut y_values = vec![Fp25519::ONE; evaluation_points_size];
        y_values.iter_mut().for_each(|y| *y = rng.gen::<Fp25519>());
        let mut evaluated_y = vec![Fp25519::ONE; evaluation_points_size];
        lagrange_evaluation(
            &evaluation_points,
            &y_values,
            &evaluation_points,
            &mut evaluated_y,
        );

        // test evaluation at interpolation points
        assert_eq!(evaluated_y, y_values);

        // sample random polynomial in monomial form of degree `evaluation_points_size`
        let mut polynomial = vec![Fp25519::ONE; evaluation_points_size];
        polynomial
            .iter_mut()
            .for_each(|x| *x = rng.gen::<Fp25519>());
        // add random point to evaluation points
        evaluation_points.push(rng.gen::<Fp25519>());

        // evaluate polynomial at evaluation_points
        let mut y_values = vec![Fp25519::ZERO; evaluation_points_size + 1];
        evaluation_points.iter().for_each(|x_value| {
            let mut base = Fp25519::ONE;
            polynomial.iter().for_each(|coefficient| {
                y_values.iter_mut().for_each(|y| *y = *coefficient * base);
                base *= *x_value
            })
        });

        // lagrange evaluate at random point
        evaluated_y[0] = Fp25519::ONE;
        lagrange_evaluation(
            &evaluation_points[0..evaluation_points_size],
            &y_values[0..evaluation_points_size],
            std::slice::from_ref(&evaluation_points[evaluation_points_size]),
            std::slice::from_mut(&mut evaluated_y[0]),
        );

        // check equality
        assert_eq!(y_values[evaluation_points_size], evaluated_y[0]);
    }
}
