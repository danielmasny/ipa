use bitvec::{prelude::Lsb0, vec::BitVec};
use ipa_macros::Step;

use crate::{
    ff::{Error, Field, Invert},
    helpers::{Direction, ReceivingEnd},
    protocol::{context::Context, ipa_prf::malicious_security::quadratic_proofs::NIDZKP},
};

#[derive(Step)]
pub(crate) enum Step {
    SendProof,
    VerifyProof,
}

/// multiplication variables
/// consists of intermediate variables computed during an MPC multiply:
/// `z_l`, `z_r`, `x_l`, `x_r`, `y_l`, `y_r`, `alpha`
/// `z_r` has been generated by the party itself while party receives `z_l` from party on the right
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct multiplication_variables {
    z_l: BitVec<u8, Lsb0>,
    z_r: BitVec<u8, Lsb0>,
    x_l: BitVec<u8, Lsb0>,
    x_r: BitVec<u8, Lsb0>,
    y_l: BitVec<u8, Lsb0>,
    y_r: BitVec<u8, Lsb0>,
    alpha: BitVec<u8, Lsb0>,
}

/// Function that verifies honest behavior in mpc multiplications
/// outputs 0 when one helper party acts maliciously during multiplications
///
/// Takes as inputs a vector of an array of bits
/// each array is associated to one multiplication
/// where alpha_i is the PRSS randomness and z_(i-1) is the result of multiply sent by another party
pub async fn verify_multiply<C, F>(ctx: C, input: &multiplication_variables) -> Result<bool, Error>
where
    C: Context,
    F: Field + Invert,
{
    // convert inputs into `F`

    // call `generate_proof`

    // send & receive proofs
    // call `send_and_receive_proofs`

    // verify proofs
    // call `verify_proofs`

    Ok(true)
}

pub fn convert_variables_into_field<F>(variables: multiplication_variables) -> (Vec<F>, Vec<F>)
where
    F: Field,
{
    //placeholder:
    return (vec![F::ONE; 7], vec![F::ONE; 7]);
}

pub async fn send_and_receive_proof<C, F>(
    ctx: C,
    proofs: Vec<NIDZKP<F>>,
) -> Result<Vec<NIDZKP<F>>, Error>
where
    C: Context,
    F: Field + Invert,
{
    // let send_channel_right: SendingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     //placeholder:
    //     .set_total_records(1)
    //     .send_channel(ctx.role().peer(Direction::Right));

    // placeholder:
    // send_channel_left.send(RecordId::from(1), (hash_left,proof_left)).await?;

    // let receive_channel_left: ReceivingEnd<> = ctx
    //     .narrow(&Step::SendProofLeft)
    //     // placeholder:
    //     .set_total_records(1)
    //     .recv_channel(ctx.role().peer(Direction::Left));

    // let (hash_left,proof_left) =
    //     receive_channel_left.receive(RecordId::from(1)).await?;

    // placeholder:
    Ok(proofs)
}
